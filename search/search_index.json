{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"about/","title":"About","text":"<p>The Python Guide is a comprehensive guide and tutorial for the Python programming language.</p> <p>This guide is focused to be:</p> <ul> <li>Comprehensive: covering all important aspects of the language</li> <li>Beginner friendly: suitable for absolute beginners</li> <li>Free to access: entirely free of any cost</li> <li>Chronological: topics are sorted in chronological order</li> <li>Navigable: the interface and structure is easy to comprehend</li> <li>Up-to-date: always up-to-date with modern features and practices</li> <li>Open source: powered by and encourages community contributions</li> </ul> <p>Note</p> <p>The Python Guide is currently under active development. Coverage of many other features of the language will be available soon.</p>"},{"location":"about/#outline","title":"Outline","text":"<p>This guide covers the topics in a chronological order starting from introductory concepts and ascending to more complex and advanced topics.</p> <p>The outline of this guide is:</p> <ul> <li>Introduction</li> </ul> <ol> <li>Getting Started</li> <li>Fundamental Concepts</li> <li>Control Structures</li> <li>String Operations</li> <li>Functions</li> <li>Exception Handling</li> <li>Data Structures</li> </ol> <p>More topics are being added and will be available soon.</p>"},{"location":"about/#inspiration","title":"Inspiration","text":"<p>The structure of this guide takes a lot of inspiration from the The Rust Programming Language book. The color scheme used in this website is inspired by Python's color scheme.</p>"},{"location":"about/#contributing","title":"Contributing","text":"<p>The Python Guide is powered by and encourages community contributions. For users looking to contribute, please read the Contributor Guide.</p>"},{"location":"about/#donate","title":"Donate","text":"<p>The Python Guide is a completely free resource and will never restrict any of its content behind a paywall.</p> <p>However, if you find this guide helpful and want to show some support and appreciation, you can donate using one of the following links:</p> <ul> <li> BuyMeACoffee</li> <li> Ko-Fi</li> </ul> <p>All the support and donations are highly appreciated and are used to improve this guide and other resources.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>Before we dive into the world of Python programming, let us get a brief introduction to this programming language and some of its main features.</p> <p>Info</p> <p>If you are already familiar with introduction of Python or don't wish to have a background of this language before learning, feel free to skip this page.</p> <p>Python is a general purpose programming language known for its simplicity and flexibility.</p>"},{"location":"introduction/#why-python","title":"Why Python?","text":"<p>Well, this is a good question. Why should you learn Python? What is good about it?</p> <p>Simplicity: The syntax of this programming language is easy to comprehend. This is why people who are new to programming often prefer learning Python as their first programming language as it takes lesser time to learn than some other programming languages.</p> <p>Flexibility: Despite its simplicity, Python is flexible and is used in a variety of applications. From simple applications to complex real world applications, Python can be used in most use cases. This is why it's called a \"general purpose language\". Worth mentioning that Python is the go-to language for data science and machine learning.</p> <p>Large Community: Python has a large and ever-growing community of developers. With extensive support for multiple domains of application, this makes Python a worth learning language.</p>"},{"location":"contributing/","title":"Contributor Guide","text":"<p>The Python Guide is powered by and encourages community contributions. All kind of contributions whether minor or major are welcome in this project.</p> <ul> <li> <p>If you are looking to report or discuss error, misleading information or    simply want to suggest a new feature, please read   this section.</p> </li> <li> <p>If you are looking to fix an issue or contribute a new article/section,   please start reading from this section</p> </li> </ul>"},{"location":"contributing/development/","title":"Working with project code","text":"<p>This section outlines the basic guidelines and conventions for the source code of this guide.</p>"},{"location":"contributing/development/#directory-structure","title":"Directory structure","text":"<p>The <code>docs/</code> folder consists of the source code for the guide.</p> <ul> <li><code>docs/_images/</code> stores the images that are used in the guide.</li> <li><code>docs/_styles/</code> stores the CSS stylesheets used for website.</li> <li><code>docs/_templates/</code> stores Jinja templates used for websites.</li> <li>Other directories and files in this folder correspond to the appropriate   sections in the guide.</li> </ul>"},{"location":"contributing/development/#theme","title":"Theme","text":"<p>This guide uses MkDocs Material theme theme.</p> <p>Elements of the theme that are commonly used are listed below with their corresponding documentation. For other elements, please see the documentation of Material theme.</p> <ul> <li>Admonitions</li> <li>Annotations</li> <li>Code Blocks</li> <li>Content Tabs</li> </ul>"},{"location":"contributing/development/#code-blocks","title":"Code blocks","text":"<p>Code blocks in the guide are showcased using the Content Tabs feature of the theme.</p> <p>Each code block has at least two tabs: one for code, other for output</p> <p>Example: <pre><code>=== \"Code\"\n\n    ```py\n    print('code here!')\n    ```\n\n=== \"Output\"\n\n    &lt;!-- Expected output is added here as a markdown codeblock --&gt;\n\n    ```\n    code here!\n    ```\n</code></pre> Above code is displayed as:</p> CodeOutput <pre><code>print('code here!')\n</code></pre> <pre><code>code here!\n</code></pre> <p>In some cases, <code>Output</code> tab is named as <code>Error</code> tab indicating that an error is raised by the code.</p> <p>Sometimes there may be multiple <code>Output</code> tabs to showcase different outputs (e.g. for different inputs). In this case, each output  tab is numbered.</p> <pre><code>=== \"Code\"\n\n    ```py\n    num = input('enter a number:')\n    ```\n\n=== \"Output #1\"\n\n    ```\n    enter a number: 25\n    ```\n\n=== \"Output #2\"\n\n    ```\n    enter a number: 22\n    ```\n</code></pre>"},{"location":"contributing/issues/","title":"Reporting &amp; Discussing issues","text":"<p>If you have found an issue in the guide such as an error, misleading information or incorrect information that you'd like to report or discuss or if you simply want to suggest an addition or improvement, this section is for you.</p> <p>We use GitHub issues for issue reports, feature requests and discussions. To open a new issue, head over to GitHub issues and create a new issue by clicking  \"New issue\".</p> <p>Select the appropriate option depending on the type of your issue and in the given section, describe your issue before opening it. Make sure you include the following in your issue description:</p> <ul> <li>Source of issue (if reporting error, or misleading information e.g. the link to page having the issue)</li> <li>Detailed description of the issue.</li> <li>If you have any solution, feel free to suggest it.</li> <li>Any additional information about the issue</li> </ul>"},{"location":"contributing/issues/#guidelines-for-issues","title":"Guidelines for issues","text":"<ul> <li>Please check the existing issues before creating a new one to avoid   duplicate issues. Duplicate issues would be closed.</li> <li>Once an issue is created, other members can see it and provide their   feedback.</li> <li>Please keep the discussion friendly and respect feedback and opinions.</li> </ul>"},{"location":"contributing/pull-requests/","title":"Pull Requests","text":"<p>Note</p> <p>Basic knowledge of Git and GitHub is required and assumed.</p> <p>If you're looking to fixing an issue, improving or contributing a new section, this section is for you.</p> <p>To start, fork the GitHub repository and clone it. It is recommended to create a new  branch in your fork to avoid conflicts and commit history issues.</p> <p>To create a new branch, run the following commands in your cloned fork git repository: <pre><code>$ git checkout -b put-branch-name-here\n</code></pre></p> <p>Push the changes and open a new pull request.</p>"},{"location":"contributing/pull-requests/#guidelines","title":"Guidelines","text":"<ul> <li>All pull requests should point to the <code>main</code> branch.</li> <li>It is recommended to use past tense in your commit messages for consistency   purposes.</li> <li>Make sure to keep the scope pull request minimal. A single pull request   should focus on a single issue instead of many issues.</li> </ul> <p>Above guidelines are not strict rules and any issues in pull requests will be addressed while merging.</p> <p>To get a know-how of how this project is structured and the common  practices and guidelines for this project's source code, read the next  section.</p>"},{"location":"control-structures/conditionals-continued/","title":"3.4. Conditionals (Continued)","text":"<p>In section 3.2. Basic Conditionals, we learned about some basic constructs which are used to make decisions on the basis of some condition, more specifically, the <code>if</code> and <code>else</code> constructs.</p> <p>In this section, we'll dig deeper into these two statements and learn a new construct, <code>elif</code>.</p>"},{"location":"control-structures/conditionals-continued/#nested-if-statements","title":"Nested <code>if</code> statements","text":"<p>You can write if statements inside if statements.</p> CodeOutput (age: 18, score: 10)Output (age: 18, score: 3)Output (age: 15, score: 10) <pre><code>age = int(input('Enter your age: '))\ntest_score = float(input('Enter driving test score: '))\n\nif age &gt;= 18:\n    if test_score &gt; 7:\n        print('You are over 18 and passed driving test so you can drive.')\n    else:\n        print('You failed driving test so you cannot drive.')\nelse:\n    print('You cannot drive because you are under 18.')\n</code></pre> <pre><code>Enter your age: 18\nEnter driving test score: 10\nYou are over 18 and passed driving test so you can drive.\n</code></pre> <pre><code>Enter your age: 18\nEnter driving test score: 3\nYou failed driving test so you cannot drive.\n</code></pre> <pre><code>Enter your age: 15\nEnter driving test score: 10\nYou cannot drive because you are under 18.\n</code></pre> <p>Note that each if statement has its own code block and is indented accordingly. The second if statement is part of code block of first if statement.</p> <p>Using <code>and</code> instead of nested <code>if</code></p> <p>Nesting if statements is equivalent to using <code>and</code> on the two logical expressions. The above code can be shortened to following:</p> CodeOutput (age: 18, score: 10)Output (age: 18, score: 3)Output (age: 15, score: 10) <pre><code>age = int(input('Enter your age: '))\ntest_score = float(input('Enter driving test score: '))\n\nif age &gt;= 18 and test_score &gt; 7:\n    print('You are over 18 and passed driving test so you can drive.')\nelse:\n    print('You cannot drive.')\n</code></pre> <pre><code>Enter your age: 18\nEnter driving test score: 10\nYou are over 18 and passed driving test so you can drive.\n</code></pre> <pre><code>Enter your age: 18\nEnter driving test score: 3\nYou cannot drive.\n</code></pre> <pre><code>Enter your age: 15\nEnter driving test score: 10\nYou cannot drive.\n</code></pre>"},{"location":"control-structures/conditionals-continued/#the-elif-statement","title":"The <code>elif</code> statement","text":"<p>The code shown below takes three numbers and outputs the largest number from the three given numbers.</p> CodeOutput <pre><code>a = int(input('Enter first number: '))\nb = int(input('Enter second number: '))\nc = int(input('Enter third number: '))\n\nif a &gt;= b and a &gt;= c:\n    print(a, 'is largest number from given numbers')\nelse:\n    if b &gt;= a and b &gt;= c:\n        print(b, 'is largest number from given numbers')\n    else:\n        if c &gt;= a and c &gt;= b:\n            print(c, 'is largest number from given numbers')\n</code></pre> <pre><code>Enter first number: 20\nEnter second number: 14\nEnter third number: 24\n24 is largest number from given numbers\n</code></pre> <p>The code works as expected. However, if you look at the lines below the first <code>else</code> statement, there are so many nested if statements that it makes the code unnecessarily confusing.</p> <p>To overcome this problem, we'll use the <code>elif</code> construct.</p> CodeOutput <pre><code>a = int(input('Enter first number: '))\nb = int(input('Enter second number: '))\nc = int(input('Enter third number: '))\n\nif a &gt;= b and a &gt;= c:\n    print(a, 'is largest number from given numbers')\nelif b &gt;= a and b &gt;= c:\n    print(b, 'is largest number from given numbers')\nelif c &gt;= a and c &gt;= b:\n    print(c, 'is largest number from given numbers')\n</code></pre> <pre><code>Enter first number: 20\nEnter second number: 14\nEnter third number: 24\n24 is largest number from given numbers\n</code></pre> <p>As you can see, the code looks much easier to read now.</p> <p><code>elif</code> is short for \"else if\" and is equivalent to a nested if inside an else block:</p> Without elifWith elif <pre><code>if condition_1:\n    print('do something')\nelse:\n    if condition_2:\n        print('do something else')\n</code></pre> <pre><code>if condition_1:\n    print('do something')\nelif condition_2:\n    print('do something else')\n</code></pre> <p><code>elif</code> is a way of saying \"if previous condition didn't satisfy, check this condition\"</p> <p>You can stack as many <code>elif</code> statements as you want but note that first statement is always an <code>if</code>.</p> CodeOutput (Red)Output (Green)Output (Magenta) <pre><code>color = input('Enter a color: ')\ncolor = color.lower()  # (1)!\n\nif color == 'red':\n    print('Color code for red: #FF0000')\nelif color == 'blue':\n    print('Color code for blue: #0000FF')\nelif color == 'green':\n    print('Color code for green: #008000')\nelse:\n    print(color, 'color is not supported')\n</code></pre> <ol> <li> <p><code>color.lower()</code> is a method that converts the string to lowercase. This is done to make     the comparison easier as user might give input in mixed case (e.g. <code>rEd</code> or <code>Red</code>).</p> <p>If we don't do this, then comparison would fail if user provides a mixed case input. (e.g. <code>\"Red\" == \"red\"</code> evaluates to False)</p> <p>These methods are covered in detail in a later section.</p> </li> </ol> <pre><code>Enter a color: Red\nColor code for red is #FF0000\n</code></pre> <pre><code>Enter a color: Green\nColor code for green is #008000\n</code></pre> <pre><code>Enter a color: Magenta\nmagenta color is not supported\n</code></pre> <p>The final <code>else</code> is executed when none of the conditions above it are satisfied.</p>"},{"location":"control-structures/conditionals-continued/#exercise","title":"Exercise","text":"<p>Exercise</p> ProblemSolution <p>Write a program that takes two numbers and calculate their sum.</p> <ul> <li>if both numbers are even, add them</li> <li>if both numbers are odd, subtract larger number with smaller</li> <li>if one number is odd and other is even, multiply them</li> </ul> <p>Output the result of operation.</p> <p>HINT:</p> <p>If a number is even, the remainder of dividing it with 2 is always 0 otherwise it is 1. See section 2.4. Mathematical Operations: Other Operations for more information.</p> <pre><code>n1 = int(input('Enter first number: '))\nn2 = int(input('Enter second number: '))\n\nif (n1 % 2 == 0) and (n2 % 2 == 0):\n    # both numbers are even\n    result = n1 + n2\nelif (n1 % 2 == 1) and (n2 % 2 == 1):\n    # both numbers are odd\n    if n1 &gt; n2:\n        result = n1 - n2\n    else:\n        result = n2 - n1\nelse:\n    result = n1 * n2\n\nprint(result)\n</code></pre> <p>Alternative approaches:</p> <ul> <li>Line 9-12 could be replaced with <code>result = abs(n2 - n1)</code> which returns the   absolute (unsigned) value of subtraction result.</li> </ul>"},{"location":"control-structures/conditionals/","title":"3.1. Basic Conditionals","text":"<p>Every program needs to make some decisions during its executions. These decisions are typically made on the basis of the user input. To make such decisions, we use conditional statements.</p> <p>In this article, we'll understand the basic <code>if</code> and <code>else</code> statements used for making decisions on the basis of logical expressions (conditions).</p>"},{"location":"control-structures/conditionals/#if-statement","title":"<code>if</code> statement","text":"<p>Let us understand this with an example:</p> CodeOutput (Input: 23)Output (Input: 15) <pre><code>age = int(input('Enter your age: '))\n\nif age &gt;= 18:\n    print('You are over 18.')\n    print('You can drive.')\n</code></pre> <pre><code>Enter your age: 23\nYou are over 18.\nYou can drive.\n</code></pre> <pre><code>Enter your age: 15\n</code></pre> <p>As you can see, when we give a number greater than or equal to 18, the program produces an output showing that the user can drive.</p> <p><code>age &gt; 18</code> is a logical expression and when it evaluates to <code>True</code>, the indented lines are executed. Logical expressions are covered in detail in a later topic.</p>"},{"location":"control-structures/conditionals/#else-statement","title":"<code>else</code> statement","text":"<p>However, if the number is less than 18, the program simply exits without any message which seems a little odd. To fix this, we can include an <code>else</code> block:</p> CodeOutput (Input: 23)Output (Input: 15) <pre><code>age = int(input('Enter your age: '))\n\nif age &gt;= 18:\n    print('You are over 18.')\n    print('You can drive.')\nelse:\n    print('You are under 18.')\n    print('You cannot drive yet.')\n</code></pre> <pre><code>Enter your age: 23\nYou are over 18.\nYou can drive.\n</code></pre> <pre><code>Enter your age: 15\nYou are under 18.\nYou cannot drive yet.\n</code></pre> <p>The <code>else</code> block is executed when the <code>if</code> is not executed.</p>"},{"location":"control-structures/conditionals/#indentation","title":"Indentation","text":"<p>The lines after <code>if</code> statement are indented (leading spaces before the line of code) to indicate that they are executed only when the <code>if</code> condition is satisfied.</p> <pre><code>age = int(input('Enter your age: '))\n\nif age &gt;= 18:\n    print('You are over 18.') # (1)!\n    print('You can drive.')\nelse:\n    print('You are under 18.')\n    print('You cannot drive yet.')\n</code></pre> <ol> <li>Highlighted lines indicate the code block executed when expression <code>age &gt;= 18</code> evaluates to True.</li> </ol> <p>Similarly, the lines after <code>else</code> statement are indented to indicate that they are executed only when <code>else</code> is reached (i.e. when condition is not satisfied.)</p> <pre><code>age = int(input('Enter your age: '))\n\nif age &gt;= 18:\n    print('You are over 18.')\n    print('You can drive.')\nelse:\n    print('You are under 18.') # (1)!\n    print('You cannot drive yet.')\n</code></pre> <ol> <li>Highlighted lines indicate the code block executed when expression <code>age &gt;= 18</code> evaluates to False.</li> </ol> <p>In Python, the indentation (i.e. the leading spaces before the code) in both clause bodies is significant. The next page discusses the concept of indentation in detail.</p> <p>The concept of conditionals is continued in 3.4. Conditionals (Continued)</p>"},{"location":"control-structures/for-loop/","title":"3.6. The \"for\" loop","text":"<p>Sometimes, we want to repeatively execute some piece of code. To do this, we use loops. The next few sections of the guide will cover how loops work in Python.</p> <p>In this section, we'll learn about the <code>for</code> loop.</p>"},{"location":"control-structures/for-loop/#understanding-for-loop","title":"Understanding <code>for</code> loop","text":"<p>A <code>for</code> loop is used to iterate through an iterable. The syntax for this loop is like so:</p> <pre><code>for variable in iterable:\n    # ... code to execute here ...\n</code></pre> <p>For example, here's a really basic for-loop that prints the first 10 numbers starting from 0 and ending at 9.</p> CodeOutput <pre><code>for num in range(10):\n    print(num)\n</code></pre> <pre><code>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre> <p>Don't worry if you don't understand what is happening here as we'll go through that in a minute.</p> <p>If you're a beginner, you might find the terms \"iterating\", \"iteration\" and \"iterable\" confusing so lets see what each of these terms exactly mean.</p>"},{"location":"control-structures/for-loop/#basic-loop-terminologies","title":"Basic loop terminologies","text":"<p>There are some terms that are used when talking about loops, or repetition in general. It is important that you know the meaning of these terms as these terms are used frequently in programming.</p> <p>These terms are explained in simple words below. Note that these are not technical definitions.</p> <ul> <li> <p>Iterating means going through or processing the elements present in an iterable.</p> </li> <li> <p>Iterable could be a string of characters, range of numbers (as shown above),   some data structure, or any other sequence that could have many elements.</p> </li> </ul>"},{"location":"control-structures/for-loop/#iterating-over-range-of-numbers","title":"Iterating over range of numbers","text":"<p>The most basic and common use of a for loop is iterating over a range of numbers. To do so, we use the <code>range()</code> function.</p> <p>We've already seen an example above that uses this <code>range()</code> function but let us understand it more deeply.</p> CodeOutput <pre><code>for num in range(10):\n    print(num)\n</code></pre> <pre><code>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre> <p>To shed some light on the syntax,</p> <ul> <li><code>range(10)</code> is the iterable here that can iterate from <code>0</code> to <code>9</code>.</li> <li><code>num</code> is the variable which is assigned the number being processed on each iteration.</li> <li><code>print(num)</code> is the body of loop which is executed on each iteration (loop body could be   multiple lines of code too)</li> </ul> <p>When we execute above code, we're basically telling Python to go through the items in the <code>range(10)</code> iterable (numbers from 0 to 9) and for each item, assign the item to <code>num</code> variable and execute the body of loop (line 2).</p> <p>Each execution of the loop body (line 2) is referred to as a single iteration and when we say \"first iteration\", we're referring to first execution of the loop, when <code>num</code> is set to <code>0</code>. There are a total of 10 iterations i.e the loop body is executed ten times (from <code>num=0</code> to <code>num=9</code>).</p>"},{"location":"control-structures/for-loop/#manipulating-range-function","title":"Manipulating <code>range()</code> function","text":"<p>The <code>range()</code> function can be used in a number of ways to modify the range of numbers that are iterated through.</p> <ul> <li> <p><code>range(end)</code> iterates from <code>0</code> to <code>end - 1</code> (upper bound, <code>end</code>, is exclusive)</p> CodeOutput <pre><code>for num in range(10):\n    print(num)\n</code></pre> <pre><code>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre> </li> <li> <p><code>range(start, end)</code> iterates from <code>start</code> to <code>end - 1</code> (upper bound, <code>end</code>, is exclusive)</p> CodeOutput <pre><code>for num in range(1, 11):\n    print(num)\n</code></pre> <pre><code>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n</code></pre> <p>Tip</p> <p><code>range(10)</code> and <code>range(0, 10)</code> are both equivalent. In former, the <code>start</code> is automatically defaulted to <code>0</code>.</p> </li> <li> <p><code>range(start, end, step)</code> iterates from <code>start</code> to <code>end - 1</code> with an increment of   <code>step</code> on each iteration</p> <p>On every iteration, <code>step</code> is added to previous number. By default (when no step is provided), the <code>step</code> is set to 1.</p> CodeOutput <pre><code>for num in range(0, 10, 2):\n    print(num)\n</code></pre> <pre><code>0\n2\n4\n6\n8\n</code></pre> <p>It is also possible to move backwards (descending range) by providing step as <code>-1</code></p> CodeOutput <pre><code>for num in range(10, 0, -1):\n    print(num)\n</code></pre> <pre><code>10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n</code></pre> </li> </ul> <p>Exclusive Upper Bound</p> <p>Remember! the upper bound or <code>end</code>, in <code>range()</code> is always exclusive. This means:</p> <ul> <li><code>range(10)</code> iterates from 0 to 9.</li> <li><code>range(1, 10)</code> iterates from 1 to 9.</li> <li><code>range(0, 10, 2)</code> has elements 0, 2, 4, 6, 8 while <code>range(0, 12, 2)</code> has elements   0, 2, 4, 6, 8, 10.</li> </ul> <p>Repeatedly executing a code</p> <p>If you repeatedly want to execute same block of code, you can do this using the same <code>range()</code> approach:</p> CodeOutput <pre><code>for num in range(10):  # execute 10 times\n    print('Hello World')\n</code></pre> <pre><code>Hello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\n</code></pre>"},{"location":"control-structures/for-loop/#iterating-over-string-characters","title":"Iterating over string characters","text":"<p>If we have a string, we can use a for loop to iterate over the characters of that string.</p> CodeOutput <pre><code>for char in 'London':\n    print(char)\n</code></pre> <pre><code>L\no\nn\nd\no\nn\n</code></pre> CodeOutput <pre><code>word = input('Enter a word: ')\n\nfor char in word:\n    print(char)\n</code></pre> <pre><code>Enter a word: Hello\nH\ne\nl\nl\no\n</code></pre>"},{"location":"control-structures/for-loop/#exercise","title":"Exercise","text":"<p>We'll learn about more iterables that for loop can iterate over later in the guide such as data structures but for now, here's a simple task for you:</p> <p>Exercise</p> ProblemSolution <p>Take two numbers as input and output the times table of first number from 1 to second number.</p> <p>You must use a <code>for</code> loop for this problem.</p> <p>Example output: <pre><code>Enter a number: 2\nEnter the end point: 12\n\n2 * 1 = 2\n2 * 2 = 4\n2 * 3 = 6\n2 * 4 = 8\n2 * 5 = 10\n2 * 6 = 12\n2 * 7 = 14\n2 * 8 = 16\n2 * 9 = 18\n2 * 10 = 20\n2 * 11 = 22\n2 * 12 = 24\n</code></pre></p> <p>Highlighted lines are the input.</p> <pre><code>num = int(input('Enter a number: '))\nend = int(input('Enter the end point: '))\n\nfor x in range(1, end + 1):  # (1)!\n    result = num * x\n    print(num, '*', x, '=', result)  # num * x = result\n</code></pre> <ol> <li>The upper bound, <code>end</code>, in <code>range(start, end)</code> is exclusive so we add <code>1</code>    to the <code>end</code> variable to include <code>end</code> in our output.</li> </ol>"},{"location":"control-structures/indentation/","title":"3.2. Indentation &amp; Code blocks","text":"<p>Before we move on to learning more about conditionals, it is important that you know about how indentation works in Python as indentation will be used a lot in Python.</p>"},{"location":"control-structures/indentation/#indentation-and-code-block","title":"Indentation and Code block","text":"<p>Python is one of the many programming languages that use indentation for representing code blocks. Other programmings like C, C++, JavaScript etc. use curly brackets to represent code blocks.</p> <p>Simply speaking, Indentation are spaces in the beginning of line of code to represent that a code is part of a code block.</p> <p>A block of code comprises lines of code that are intended to execute under a certain condition. A colon <code>:</code> usually indicates the starting of a code block.</p> <p>If we look at the following code similar to the code shown on previous page,</p> CodeOutput (Input: 23)Output (Input: 15) <pre><code>age = int(input('Enter your age: '))\n\nif age &gt;= 18:\n    print('You are over 18.')\n    print('You can drive.')\nelse:\n    print('You are under 18.')\n    print('You cannot drive yet.')\n</code></pre> <pre><code>Enter your age: 23\nYou are over 18.\nYou can drive.\n</code></pre> <pre><code>Enter your age: 15\nYou are under 18\nYou cannot drive yet.\n</code></pre> <ol> <li>The colon indicates the starting of code block</li> <li>The code block for the <code>if</code> statement</li> <li>The code block for the <code>else</code> statement</li> </ol> <p>In this code, both blocks of code comprise two lines of code only but could have any number of lines.</p> <p>An error will be raised if indentation is skipped:</p> CodeOutput <pre><code>if age &gt;= 18:\nprint('You are over 18 so you can drive')\n</code></pre> <pre><code>  File \"G:\\thepyguide\\main.py\", line 3\n    print('You are over 18 so you can drive.')\n    ^\nIndentationError: expected an indented block after 'if' statement on line 2\n</code></pre>"},{"location":"control-structures/indentation/#rules-for-indentation","title":"Rules for Indentation","text":"<p>There are a following rules for indentation that are discussed below.</p>"},{"location":"control-structures/indentation/#number-of-spaces","title":"Number of spaces","text":"<p>It doesn't matter how many number of spaces are used for indentation but it should be at least one. The convention is to use 4 spaces (equivalent to a Tab).</p> <p>In most code editors, pressing the Tab key would automatically indent by four spaces. Note that four spaces are conventionally preferred over a raw Tab character and most code editors treat pressing the Tab as equivalent to pressing spacebar four times.</p> CodeOutput <pre><code>age = int(input('Enter your age: '))\n\nif age &gt;= 18:\n    print('You are over 18')  # 4 spaces\nelse:\n        print('You are not over 18')  # 8 spaces\n</code></pre> <pre><code>Enter your age: 23\nYou are over 18\n</code></pre> <p>Though no errors are raised by the code above, it is a good practice to keep the indentation consistent throughout the code.</p>"},{"location":"control-structures/indentation/#consistent-indentation","title":"Consistent indentation","text":"<p>The indentation in same code block must be consistent. That is, in a certain code block that has multiple lines, the indentation for each line should be same throughout that code block.</p> CodeOutput <pre><code>age = int(input('Enter your age: '))\n\nif age &gt;= 18:\n    print('You are over 18')  # 4 spaces\n    print('So you can drive')\nelse:\n        print('You are not over 18')  # 8 spaces\n    print('So you cannot drive')  # 4 spaces\n</code></pre> <pre><code>  File \"G:\\thepyguide\\main.py\", line 8\n    print('So you cannot drive')  # 4 spaces\n                                        ^\nIndentationError: unindent does not match any outer indentation level\n</code></pre> <p>As you can see, in the <code>else</code> code block, the first line is indented with 8 spaces and the second line is indented with 4 spaces.</p> <p>To resolve the error, either the second line in code block has to be indented 8 spaces too or the first line has to be indented with 4 spaces.</p> <p>Tip</p> <p>Writing pretty code is as important as writing efficient code. The conventional practice is to stick to 4 spaces for indentation throughout your code.</p> <p>While Python allows different indentation for individual code blocks, the best practice is to stay consistent.</p>"},{"location":"control-structures/indentation/#tabs-and-spaces","title":"Tabs and spaces","text":"<p>Either Tab can be used for indentation or four spaces. In most code editors, pressing a Tab adds four spaces. However, both tabs and spaces cannot be mixed or a <code>TabError</code> is raised.</p> <p>Tip</p> <p>The preferred and good practice is to always use spaces for indentation because tabs can affect readiblity of code on different code editors.</p> <p>This is why most code editors treat pressing a Tab as pressing Space four times.</p>"},{"location":"control-structures/logical-operations/","title":"3.3. Logical Operations","text":"<p>In section 3.1. Basic Conditionals, we learned about <code>if</code> and <code>else</code> constructs that are used to perform operation on some condition.</p> <p>In this section, we'll learn about logical operations that are used to manipulate the conditions in <code>if</code> statements.</p>"},{"location":"control-structures/logical-operations/#the-boolean-type","title":"The boolean type","text":"<p>In the section 2.1. Variables and Data Types, we learned about the \"boolean data type\" which is referred to as <code>bool</code> in Python.</p> <p>For a recap, <code>bool</code> data type is used to represent a boolean value which in turn, means either True or False. Result of logical operations is a boolean value.</p>"},{"location":"control-structures/logical-operations/#basic-logical-operations","title":"Basic logical operations","text":"<p>Let us understand this with an example, if we have a variable <code>age</code> representing the age of a user, we can check whether the user can drive or not by checking whether the age is above 18 or not.</p> CodeOutput <pre><code>age = 12\nprint('Can user drive?', age &gt; 18)\n</code></pre> <pre><code>Can user drive? False\n</code></pre> <p>If we change the value of <code>age</code> to say, <code>23</code>, we get:</p> CodeOutput <pre><code>age = 23\nprint('Can user drive?', age &gt; 18)\n</code></pre> <pre><code>Can user drive? True\n</code></pre> <p>Here, <code>age &gt; 18</code> is a logical expression. This expression uses the <code>&gt;</code> logical operator to check whether the age is greater than <code>18</code>.</p> <p>A logical expression is formed using logical operators and can either evaluate to True or False. The basic logical operators that can be used are:</p> <ul> <li><code>==</code> (Equals to)</li> <li><code>!=</code> (Not Equals to)</li> <li><code>&gt;</code> (Greater than)</li> <li><code>&lt;</code> (Less than)</li> <li><code>&gt;=</code> (Greater than or equal to)</li> <li><code>&lt;=</code> (Less than or equal to)</li> </ul> CodeOutput (Input: 18)Output (Input: 12)Output (Input: 23) <pre><code>age = int(input('Enter an age:'))\n\nprint('Is 18?', age == 18)\nprint('Not 18?', age != 18)\nprint('Above 18?', age &gt; 18)\nprint('Above 18 or Is 18?', age &gt;= 18)\nprint('Below 18?', age &lt; 18)\nprint('Below 18 or Is 18?', age &lt;= 18)\n</code></pre> <pre><code>Enter an age: 18\nIs 18? True\nNot 18? False\nAbove 18? False\nAbove 18 or Is 18? True\nBelow 18? False\nBelow 18 or Is 18? True\n</code></pre> <pre><code>Enter an age: 12\nIs 18? False\nNot 18? True\nAbove 18? False\nAbove 18 or Is 18? False\nBelow 18? True\nBelow 18 or Is 18? True\n</code></pre> <pre><code>Enter an age: 23\nIs 18? False\nNot 18? True\nAbove 18? True\nAbove 18 or Is 18? True\nBelow 18? False\nBelow 18 or Is 18? True\n</code></pre> <p>We can use logical expressions in an <code>if</code> statement (as seen in section 3.1) to perform an action based on whether expression evaluates to True or False.</p> CodeOutput (Input: 23)Output (Input: 18)Output (Input: 12) <pre><code>age = int(input('Enter an age:'))\n\nif age &gt;= 18:\n    print('You can drive.')\nelse:\n    print('You cannot drive.')\n</code></pre> <pre><code>Enter an age: 23\nYou can drive.\n</code></pre> <pre><code>Enter an age: 18\nYou can drive.\n</code></pre> <pre><code>Enter an age: 12\nYou cannot drive.\n</code></pre> <p>Here, <code>age &gt;= 18</code> is the logical expression and the print statement is only executed when this expression evaluates to True.</p>"},{"location":"control-structures/logical-operations/#and-or-and-not-operators","title":"AND, OR and NOT operators","text":"<p>In some cases, you have multiple expressions that you have to check for.</p>"},{"location":"control-structures/logical-operations/#and-operator","title":"AND operator","text":"<p><code>and</code> is a logical operator that checks whether all conditions are True. If any one or more of the conditions are not satisfied, the result is False.</p> <p>As an example, in order for user to be able to drive, following conditions must be satisfied:</p> <ul> <li>the user must be 18 years or above</li> <li>the user must have above 6.5 on driving test</li> </ul> <p>We can represent this like so:</p> CodeOutput (age: 18, score: 10)Output (age: 12, score: 10)Output (age: 23, score: 6) <pre><code>age = int(input('Enter your age: '))\ndriving_test_score = float(input('Enter your driving test score: '))\n\nif age &gt;= 18 and driving_test_score &gt; 6.5:\n    print('You can drive.')\nelse:\n    print('You cannot drive.')\n</code></pre> <pre><code>Enter your age: 18\nDriving test score: 10\nYou can drive.\n</code></pre> <p>Here, <code>driving_test_score &gt;= 6.5</code> expression results in <code>True</code> and <code>age &gt;= 18</code> results in <code>True</code>. The overall expression results in <code>True</code> because both expressions are <code>True</code>.</p> <pre><code>Enter your age: 12\nDriving test score: 10\nYou cannot drive.\n</code></pre> <p>Here, <code>driving_test_score &gt;= 6.5</code> expression results in <code>True</code> but <code>age &gt;= 18</code> results in <code>False</code>. The overall expression results in <code>False</code>.</p> <pre><code>Enter your age: 23\nDriving test score: 6\nYou cannot drive.\n</code></pre> <p>Here, <code>driving_test_score &gt;= 6.5</code> expression results in <code>False</code> but <code>age &gt;= 18</code> results in <code>True</code>. The overall expression results in <code>False</code>.</p> <p>Tip</p> <p>A logical expression produces a boolean value which can also be assigned to a variable. This is particularly useful when we have large expressions which could become confusing.</p> CodeOutput <pre><code>age = 23\ndriving_test_score = 6.5\n\nover_18 = age &gt;= 18\npassed_test = driving_test_score &gt; 7\n\nprint('Over 18?', over_18)\nprint('Passed test?', passed_test)\nprint('Can drive?', over_18 and passed_test)\n</code></pre> <pre><code>Over 18? True\nPassed test? False\nCan drive? False\n</code></pre>"},{"location":"control-structures/logical-operations/#or-operator","title":"OR operator","text":"<p>The <code>or</code> operator evaluates to True if any one or more of the given expressions are True.</p> <p>For example, lets say a customer is only eligible for discount if he or she spends at least 100$  or if the customer has shopped at store more than 10 times.</p> CodeOutput #1Output #2Output #3 <pre><code>amount_spent = int(input('Enter amount spent shopping: '))\nold_customer = input('Are you an old customer? ')\n\nif amount_spent &gt; 150 or old_customer == 'yes':\n    print('Customer gets a discount.')\nelse:\n    print('Discount not applied.')\n</code></pre> <pre><code>Enter amount spent shopping: 250\nAre you an old customer? yes\nCustomer gets a discount.\n</code></pre> <p>Here, <code>amount_spent &gt; 150</code> is <code>True</code> and <code>old_customer == 'yes'</code> is also <code>True</code> so overall expression is <code>True</code>.</p> <pre><code>Enter amount spent shopping: 50\nAre you an old customer? yes\nCustomer gets a discount.\n</code></pre> <p>Here, <code>amount_spent &gt; 150</code> is <code>False</code> but <code>old_customer == 'yes'</code> is <code>True</code> so overall expression is <code>True</code>.</p> <pre><code>Enter amount spent shopping: 40\nAre you an old customer? no\nDiscount not applied.\n</code></pre> <p>Here, <code>amount_spent &gt; 150</code> is <code>False</code> and <code>old_customer == 'yes'</code> is also <code>False</code> so overall expression is <code>False</code>.</p> <p>Simply put, if you test the following logical expressions, you'd get the mentioned result:</p> <ul> <li><code>True and True</code> evaluates to <code>True</code></li> <li><code>True and False</code> evaluates to <code>False</code></li> <li><code>False and False</code> evaluates to <code>False</code></li> <li><code>True or True</code> evaluates to <code>True</code></li> <li><code>True or False</code> evaluates to <code>True</code></li> <li><code>False or False</code> evaluates to <code>False</code></li> </ul> <p>Info</p> <ul> <li> <p>For <code>and</code>, if all expressions are True, result is True. If any expression is   False, result is False.</p> </li> <li> <p>For <code>or</code>, if any expression is True, result is True. If all expressions are False,   result is also False.</p> </li> </ul>"},{"location":"control-structures/logical-operations/#not-operator","title":"NOT operator","text":"<p>We also have a <code>not</code> operator which simply inverts the given boolean value. That is, <code>not True</code> evaluates to <code>False</code>. <code>not False</code> evaluates to <code>True</code>.</p> <p>For example, the expression in code below is <code>True</code> only when X is not greater than Y (either X &lt; Y or X = Y):</p> CodeOutput (X: 20, Y: 30)Output (X: 30, Y: 20) <pre><code>X = int(input('X: '))\nY = int(input('Y: '))\nprint('X is not greater than Y:', not (X &gt; Y))\n</code></pre> <pre><code>X: 20\nY: 30\nX is not greater than Y: True\n</code></pre> <pre><code>X: 30\nY: 20\nX is not greater than Y: False\n</code></pre> <p>This expression is just an equivalent of <code>X &lt;= Y</code>.</p>"},{"location":"control-structures/loop-control/","title":"3.8. Loop Control","text":"<p>In this section, we'll learn about two statements that are used to control a loop's flow.</p>"},{"location":"control-structures/loop-control/#break-statement","title":"<code>break</code> statement","text":"<p>The <code>break</code> statement is used to interrupt the loop and terminate it. This statement will terminate the loop immediately regardless of whether the loop condition is True or not.</p>"},{"location":"control-structures/loop-control/#using-a-while-loop","title":"Using a <code>while</code> loop","text":"CodeOutput <pre><code>while True:  # (1)!\n    password = input('Enter password: ')\n\n    if password == 'python':\n        break\n\n    print('Invalid Password')\n\nprint('Access granted')\n</code></pre> <ol> <li><code>while True:</code> indicates a loop that runs forever or until <code>break</code> statement is not executed.</li> </ol> <pre><code>Enter password: wrong\nInvalid Password\nEnter password: random input\nInvalid Password\nEnter password: python\nAccess granted\n</code></pre> <p>(Highlighted lines are inputs)</p> <p>In above <code>while</code> loop example, the program will repeatedly prompt for password until the correct one is not entered, in this case <code>python</code>.</p>"},{"location":"control-structures/loop-control/#using-a-for-loop","title":"Using a <code>for</code> loop","text":"CodeOutput (<code>gun</code>)Output (<code>london</code>)Output (<code>practice</code>) <pre><code>word = input('Enter a word')\n\nfor char in word:\n    if char == 'a':\n        print('letter A found in word')\n        break\n\n    print(char)\n</code></pre> <pre><code>Enter a word: gun\ng\nu\nn\n</code></pre> <p>(Highlighted lines are inputs)</p> <pre><code>Enter a word: london\nl\no\nn\nd\no\nn\n</code></pre> <p>(Highlighted lines are inputs)</p> <pre><code>Enter a word: practice\np\nr\nletter A found in word\n</code></pre> <p>(Highlighted lines are inputs)</p> <p>In this example, the program takes a word as input and prints its characters. As soon as an <code>a</code> character is found, the program outputs a message and loop terminates.</p>"},{"location":"control-structures/loop-control/#continue-statement","title":"<code>continue</code> statement","text":"<p>The <code>continue</code> statement is used to continue to next iteration without executing the rest of loop body.</p>"},{"location":"control-structures/loop-control/#using-a-while-loop_1","title":"Using a <code>while</code> loop","text":"CodeOutput <pre><code>x = 1\n\nwhile x &lt;= 10:\n    if x == 3:\n        continue\n\n    result = x * 2\n    print('2', '*', x, '=', result)\n    x = x + 1\n</code></pre> <pre><code>2 * 1 = 2\n2 * 2 = 4\n2 * 4 = 8\n2 * 5 = 10\n2 * 6 = 12\n2 * 7 = 14\n2 * 8 = 16\n2 * 9 = 18\n2 * 10 = 20\n</code></pre> <p>Above program prints the times table for 2 however it doesn't print the multiple of 2 with 3.</p>"},{"location":"control-structures/loop-control/#using-a-for-loop_1","title":"Using a <code>for</code> loop","text":"<p>The same program could be written with a <code>for</code> loop.</p> CodeOutput <pre><code>for x in range(1, 11)\n    if x == 3:\n        continue\n\n    result = x * 2\n    print('2', '*', x, '=', result)\n</code></pre> <pre><code>2 * 1 = 2\n2 * 2 = 4\n2 * 4 = 8\n2 * 5 = 10\n2 * 6 = 12\n2 * 7 = 14\n2 * 8 = 16\n2 * 9 = 18\n2 * 10 = 20\n</code></pre>"},{"location":"control-structures/truth-value/","title":"3.5. Truth Value","text":"<p>By definition, truth value of <code>X</code> is the True/False value returned when <code>bool(X)</code> is performed.</p> <p>In general, if any value has some content, it has a truth value of <code>True</code>. If a value does not have any content, its truth value is <code>False</code>.</p>"},{"location":"control-structures/truth-value/#truth-value-for-str-type","title":"Truth value for <code>str</code> type","text":"<p>A string has a truth value of <code>True</code> when it is non-empty.</p> CodeOutput <pre><code>print(bool(''))\nprint(bool('a'))\n</code></pre> <pre><code>False\nTrue\n</code></pre> <p>In first line, an empty string has truth value of False and in second line, a non-empty string has truth value of True.</p> <p>Note that a space is also considered a character so truth value of <code>\" \"</code> is also True.</p> CodeOutput <pre><code>print(bool(' '))\n</code></pre> <pre><code>True\n</code></pre> <p>Even if string has no actual characters, a \"space\" is still considered a character so string is not empty and has truth value of True.</p>"},{"location":"control-structures/truth-value/#truth-value-for-int-type","title":"Truth value for <code>int</code> type","text":"<p>An integer has a truth value of <code>True</code> when it is non-zero.</p> CodeOutput <pre><code>print(bool(0))\nprint(bool(1))\nprint(bool(2))\n</code></pre> <pre><code>False\nTrue\nTrue\n</code></pre>"},{"location":"control-structures/truth-value/#truth-value-for-float-type","title":"Truth value for <code>float</code> type","text":"<p>A floating point number has a truth value of <code>True</code> when it is non-zero.</p> CodeOutput <pre><code>print(bool(0.0))\nprint(bool(1.2))\n</code></pre> <pre><code>False\nTrue\n</code></pre> <p>Note that the value has to be absolutely <code>0.0</code> to be False. A value as small as <code>0.00000001</code> also has some content so its truth value is True.</p> CodeOutput <pre><code>print(bool(0.0))\nprint(bool(0.000000001))\n</code></pre> <pre><code>False\nTrue\n</code></pre>"},{"location":"control-structures/truth-value/#using-truth-values","title":"Using truth values","text":"<p>Truth values are used in <code>if</code>/<code>elif</code> statements. They are a shorthand to checking if the content of variable being checked is non-empty.</p> OutputCode <pre><code>content = ''\n\nif content:\n    print('Non-empty')\nelse:\n    print('Empty')\n</code></pre> <pre><code>Empty\n</code></pre> <p>Here, the <code>if</code> statement checks if the value of <code>content</code> is non-empty. This is roughly equivalent to:</p> <pre><code>content = ''\n\nif content != '':\n    print('Non-empty')\nelse:\n    print('Empty')\n</code></pre> <p>Same goes for integers and floats. If an integer is non-zero, only then it would evaluate to True in an if statement.</p>"},{"location":"control-structures/while-loop/","title":"3.7. The \"while\" loop","text":"<p>In previous section, we learned about the <code>for</code> loop that we can use to iterate over an iterable. In this section, we will take a look at the <code>while</code> loop.</p>"},{"location":"control-structures/while-loop/#understanding-while-loop","title":"Understanding <code>while</code> loop","text":"<p>A <code>while</code> loop, unlike <code>for</code> loop, does not iterate over an iterable. This loop is used repeatedly execute a code block until a condition is True.</p> <p>The basic syntax of this loop is like so: <pre><code>while condition:\n    # loop body here\n</code></pre></p> <p>Here, until <code>condition</code> could be a logical expression, a boolean or any true-like value, the loop body would be executed until the condition is True.</p> <p>Let us see an example, the following code prints out the numbers from 0 to 9:</p> CodeOutput <pre><code>i = 0\n\nwhile i &lt; 10:\n    print(i)\n    i = i + 1\n</code></pre> <pre><code>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre> <p>Until the variable <code>i</code> is less than 10, the while loop is going to execute.</p>"},{"location":"control-structures/while-loop/#caveats","title":"Caveats","text":"<p><code>while</code> loop comes with some extra caveats that must be taken into account.</p>"},{"location":"control-structures/while-loop/#variable-definition","title":"Variable Definition","text":"<p>In a <code>while</code> loop, the variables that are being used to control the loop (e.g. one used in condition) must be initialized before the loop. This isn't the case in a <code>for</code> loop.</p> <p>For example, in above example, since we use <code>i</code> in the condition, we must define this variable beforehand and give it an initial value. In a <code>for</code> loop, we don't have to do this.</p> <code>while</code> loop<code>for</code> loop <pre><code>i = 0\n\nwhile i &lt; 10:\n    print(i)\n    i = i + 1\n</code></pre> <pre><code>for i in range(10):\n    print(i)\n</code></pre>"},{"location":"control-structures/while-loop/#loop-termination","title":"Loop termination","text":"<p><code>while</code> loop will execute until the condition is True. It is a common pitfall to run into an \"infinite loop\" when using while loop.</p> <p>For illustration purpose, if you run the following code, you will see that the program prints <code>Hello World</code> repeatedly and never stops:</p> CodeOutput <pre><code>while True:\n    print('Hello World')\n</code></pre> <pre><code>Hello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\nHello World\n[...]\n</code></pre> <p>In the numbers example shown above, the loop terminates because the line <code>i = i + 1</code> keeps incrementing <code>i</code> until <code>i</code> becomes equal to <code>10</code> and the condition (<code>i &lt; 10</code>) becomes False.</p> <pre><code>i = 0\n\nwhile i &lt; 10:\n    print(i)\n    i = i + 1\n</code></pre> <p>If we remove that line, look at what happens:</p> CodeOutput <pre><code>i = 0\n\nwhile i &lt; 10:\n    print(i)\n</code></pre> <pre><code>0\n0\n0\n0\n0\n0\n0\n0\n0\n[...]\n</code></pre> <p>The <code>i</code> variable never updates and ultimately the <code>i &lt; 10</code> condition is always <code>True</code> causing the loop to run forever.</p> <p>Note</p> <p>In a <code>for</code> loop, incrementing the loop controlling variable is handled by <code>range()</code> and you don't have to do that manually.</p> <p>Exercise</p> ProblemSolution <p>Write a program that repeatedly takes numbers as user input until user does not enter <code>stop</code>. Once <code>stop</code> is given as input, the program should output the sum of numbers that were input.</p> <p>Example program output:</p> <pre><code>Enter a number or type \"stop\": 20\nEnter a number or type \"stop\": 10\nEnter a number or type \"stop\": 5\nEnter a number or type \"stop\": 30\nEnter a number or type \"stop\": 5\nEnter a number or type \"stop\": stop\nSum of given numbers is 70\n</code></pre> <p>Highlighted lines are user inputs.</p> <pre><code>prompt = 'Enter a number or type \"stop\": '\nresult = 0\nvalue = input(prompt)\n\nwhile value != 'stop':\n    result = result + int(value)\n    value = input(prompt)\n\nprint('Sum of given numbers is', result)\n</code></pre>"},{"location":"data-structures/copying-data-structures/","title":"7.6. Copying Data Structures","text":"<p>This section covers the difference between storing references and creating copies of data structure.</p>"},{"location":"data-structures/copying-data-structures/#reference-vs-copy","title":"Reference vs Copy","text":"<p>If we have a data structure, for example a list stored in a variable <code>x</code>:</p> <pre><code>x = ['a', 'b', 'c']\n</code></pre> <p>... and we want to create a copy of this list and store it in another variable, say <code>y</code>, what would be the way for doing that?</p> <p>A naive solution to this problem would be as simple as:</p> CodeOutput <pre><code>x = ['a', 'b', 'c']\ny = x\nprint(y)\n</code></pre> <pre><code>['a', 'b', 'c']\n</code></pre> <p>That looks fine, so far. Though there is one huge problem, we want to create a copy of <code>x</code> and store it into <code>y</code> such that <code>y</code> is an independent list but with this approach, if we change <code>y</code>, <code>x</code> list is also changed:</p> CodeOutput <pre><code>x = ['a', 'b', 'c']\ny = x\nprint('x before update:', x)\nprint('y before update:', y)\n\ny.append('d')\nprint('x after update:', x)\nprint('y after update:', y)\n</code></pre> <pre><code>x before update: ['a', 'b', 'c']\ny before update: ['a', 'b', 'c']\nx after update: ['a', 'b', 'c', 'd']\ny after update: ['a', 'b', 'c', 'd']\n</code></pre> <p>To understand what's happening here, when we assign <code>y = x</code>, we're simply creating a new variable <code>y</code> that references <code>x</code>. <code>y</code> is not a new list but merely a reference to <code>x</code>. This means whenever we access <code>y</code>, we're in turn accessing <code>x</code> instead.</p> <p>Same is the case for other data structures (except tuples because they are immutable), and virtually any mutable type.</p>"},{"location":"data-structures/copying-data-structures/#creating-copies","title":"Creating Copies","text":"<p>All data structures (except tuple) provide a <code>copy()</code> method that can be used to create a copy of that data structure.</p> CodeOutput <pre><code>x = ['a', 'b', 'c']\ny = x.copy()\nprint(y)\n</code></pre> <pre><code>['a', 'b', 'c']\n</code></pre> <p>Now, <code>y</code> is a copy of <code>x</code> instead of a reference to it. Hence, now modifying <code>y</code> would only change the new list we created instead of changing the  original list stored in <code>x</code>:</p> CodeOutput <pre><code>x = ['a', 'b', 'c']\ny = x.copy()\nprint('x before update:', x)\nprint('y before update:', y)\n\ny.append('d')\nprint('x after update:', x)\nprint('y after update:', y)\n</code></pre> <pre><code>x before update: ['a', 'b', 'c']\ny before update: ['a', 'b', 'c']\nx after update: ['a', 'b', 'c']\ny after update: ['a', 'b', 'c', 'd']\n</code></pre> <p>Note how <code>x</code> remains same both before and after the update.</p>"},{"location":"data-structures/copying-data-structures/#shallow-copy-vs-deep-copy","title":"Shallow Copy vs Deep Copy","text":"<p>What we just did is called creating a \"shallow copy.\" What is a shallow copy you may ask, so let us have another example.</p> CodeOutput <pre><code>x = ['a', 'b', 'c', [1, 2, 3]]\ny = x.copy()\nprint('x before update:', x)\nprint('y before update:', y)\n\ny.append('d')\nprint('x after update:', x)\nprint('y after update:', y)\n</code></pre> <pre><code>x before update: ['a', 'b', 'c', [1, 2, 3]]\ny before update: ['a', 'b', 'c', [1, 2, 3]]\nx after update: ['a', 'b', 'c', [1, 2, 3]]\ny after update: ['a', 'b', 'c', [1, 2, 3], 'd']\n</code></pre> <p>In this case, <code>x</code> has list has another nested list <code>[1, 2, 3]</code>. We created a copy of <code>x</code> and stored it in <code>y</code> and after that we modified <code>y</code>, adding a new element <code>\"d\"</code>.</p> <p>So far so good. However, we'll notice the problem when we try to change the nested list:</p> CodeOutput <pre><code>x = ['a', 'b', 'c', [1, 2, 3]]\ny = x.copy()\nprint('x before update:', x)\nprint('y before update:', y)\n\n# y[3] is the nested list\ny[3].append(4)\nprint('x after update:', x)\nprint('y after update:', y)\n</code></pre> <pre><code>x before update: ['a', 'b', 'c', [1, 2, 3]]\ny before update: ['a', 'b', 'c', [1, 2, 3]]\nx after update: ['a', 'b', 'c', [1, 2, 3, 4]]\ny after update: ['a', 'b', 'c', [1, 2, 3, 4]]\n</code></pre> <p>As you can see, when we update the nested list, it is updated in both <code>x</code> and <code>y</code>. This might seem unexpected because we just established that <code>x.copy()</code> creates a new copy of list which is independent of original list. This is what we call \"shallow copying\".</p> <p>Shallow copying only copies the data structure but not the elements of that data structure.</p> <p>To avoid this problem, we have deep copying that along with copying the data structure, copies the elements stored in it too. In order to use deep copying, we require an external module which will be covered in a later section.</p>"},{"location":"data-structures/sequence-operations/","title":"7.4. Sequence Operations","text":"<p>Apart from operations covered in respective sections of each sequence data structures, list, tuples and sets have some common operations.</p> <p>Note</p> <p>A general term for list, tuple and set is sequence.</p>"},{"location":"data-structures/sequence-operations/#iterating-using-for-loop","title":"Iterating using <code>for</code> loop","text":"<p>Elements of a sequence can be iterated over using a <code>for</code> loop.</p> CodeOutput <pre><code>fruits = ['apple', 'peach', 'strawberry', 'pineapple']\n\nfor fruit in fruits:\n    print(fruit)\n</code></pre> <pre><code>apple\npeach\nstrawberry\npineapple\n</code></pre> <p>This is similar to iterating over string characters.</p> <p>Note</p> <p>Keep in mind that since sets are unordered, when iterating over a set, the order in which elements are looped is not fixed.</p>"},{"location":"data-structures/sequence-operations/#typecasting","title":"Typecasting","text":"<p>We saw in section 2.1. Variables and Data Types that we can convert data from one datatype to another. This is called typecasting.</p> <p>Same is the case for sequences. <code>list</code>, <code>tuple</code> and <code>set</code> are three different data types offering a different set of operations. It is up to you to decide that which type is suitable for a given case.</p> <p>The good thing is: all of these types can be type casted into one another.</p> <p>We can call the <code>list()</code>, <code>tuple()</code> or <code>set()</code> functions to convert a sequence to the called data type.</p> CodeOutput <pre><code>list_letters = ['a', 'b', 'c']\nprint(list_letters)\n\ntuple_letters = tuple(letters)\nprint(tuple_letters)\n\nset_letters = set(letters)\nprint(set_letters)\n</code></pre> <pre><code>['a', 'b', 'c']\n('a', 'b', 'c')\n{'a', 'b', 'c'}\n</code></pre> <p>There are many reasons why you might want to convert one type to another. For example, when you want to eliminate duplicates, you can convert a sequence to set. Another case is when you want to add elements to an immutable tuple.</p>"},{"location":"data-structures/sequence-operations/#multiplication-the-operator","title":"Multiplication (the <code>*</code> operator)","text":"<p>Elements of a list and tuples can be multiplied using the <code>*</code> operator. This is similar to how did string multiplication.</p> CodeOutput <pre><code>letters = ['a', 'b', 'c']\nprint('before:', letters)\n\nletters = letters * 3\nprint(f'after:', letters)\n</code></pre> <pre><code>before: ['a', 'b', 'c']\nafter: ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']\n</code></pre> <p>As we can see in the output, the elements previously in the list were  repeated 3 times when multiplied by 3.</p> <p>It is important to note that when multiplying, the original list or tuple remains the same and a new data structure is created with updated elements.</p> CodeOutput <pre><code>letters = ('a', 'b', 'c')\nprint('before:', letters)\n\nnew_letters = letters * 3\nprint(f'after:', letters)\nprint(f'after (new):', new_letters)\n</code></pre> <pre><code>before: ('a', 'b', 'c')\nafter: ('a', 'b', 'c')\nafter (new): ('a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c')\n</code></pre> <p>Warning</p> <p>Multiplication is not possible for sets.</p>"},{"location":"data-structures/sequence-operations/#checking-membership-in-operator","title":"Checking Membership (<code>in</code> operator)","text":"<p>Python provides an <code>in</code> operator that can be used to check whether a specific item exists in a sequence.</p> CodeOutput <pre><code>letters = ('a', 'b', 'c')\n\nprint('b' in letters)\nprint('d' in letters)\n</code></pre> <pre><code>True\nFalse\n</code></pre> <p>This operator works for all data structures provided by Python.</p>"},{"location":"data-structures/sequence-operations/#common-methods","title":"Common Methods","text":"<p>Following are some commonly used methods for sequences. Other methods have been covered in respective section of each data structure.</p> <code>list.count()</code> // <code>tuple.count()</code> <p><code>count()</code> method is used to count the number of occurences of an element in list or tuple.</p> CodeOutput <pre><code>letters = ('a', 'b', 'c', 'd', 'b', 'e')\nprint('b occurs', letters.count('b'), 'times')\n</code></pre> <pre><code>b occurs 2 times\n</code></pre> <code>list.index()</code> // <code>tuple.index()</code> <p><code>index()</code> method is used to retrieve the index of an element.</p> CodeOutput <pre><code>letters = ('a', 'b', 'c', 'd')\nprint('b occurs at', letters.index('b'), 'position')\n</code></pre> <pre><code>b occurs 1 position\n</code></pre> <p>If the given element occurs more than once, only first occurence is returned.</p> <p>Optional parameters that this method takes are:</p> <ul> <li><code>start</code>: the index to start searching from.</li> <li><code>end</code>: the index to search until. (exclusive)</li> </ul>"},{"location":"data-structures/sequence-operations/#built-in-functions","title":"Built-in Functions","text":"<p>Following built-in functions can be applied on sequences:</p> <code>len()</code> <p><code>len()</code> function returns the size of a tuple or list i.e. number of elements in the data structure.</p> CodeOutput <pre><code>letters = ('a', 'b', 'c', 'd', 'b', 'e')\nprint(len(letters))\n</code></pre> <pre><code>6\n</code></pre> <code>max()</code> &amp; <code>min()</code> <p><code>max()</code> function returns the maximum value from the given sequence.</p> CodeOutput <pre><code>values = (23, 120, 636, 10, 99)\nprint(max(letters))\n</code></pre> <pre><code>636\n</code></pre> <p>Similarly, <code>min()</code> function returns the minimum value.</p> CodeOutput <pre><code>values = (23, 120, 636, 10, 99)\nprint(max(letters))\n</code></pre> <pre><code>10\n</code></pre> <p>Both <code>max()</code> and <code>min()</code> cannot be used on empty sequences.</p> <code>sum()</code> <p><code>sum()</code> function adds the values of a sequence or iterable and returns the final sum.</p> CodeOutput <pre><code>values = (320, 30, 10, 20)\nprint(sum(letters))\n</code></pre> <pre><code>380\n</code></pre> <p>The elements of sequence must be integers.</p>"},{"location":"data-structures/dictionary/accessing-items/","title":"7.5.2. Accessing Items","text":"<p>In this section, we'll see how the items stored in a dictionary can be accessed.</p>"},{"location":"data-structures/dictionary/accessing-items/#subscripting","title":"Subscripting","text":"<p>We saw this syntax in the previous section too. We can pass the key to access value of in the square brackets similar to indexing lists.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data['age'])\n</code></pre> <pre><code>25\n</code></pre> <p>In case the key provided does not exist, a <code>KeyError</code> is raised.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data['gender'])\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"C:\\XGuides\\python\\test.py\", line 6, in &lt;module&gt;\n    print(data['gender'])\n          ~~~~^^^^^^^^^^\nKeyError: 'gender'\n</code></pre>"},{"location":"data-structures/dictionary/accessing-items/#dictget-method","title":"<code>dict.get()</code> Method","text":"<p><code>dict.get()</code> method can be used to access the value corresponding to a key too.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data.get('name'))\n</code></pre> <pre><code>John\n</code></pre> <p>There's one difference in this method compared to the previous approach, if the key accessed does not exist, it returns <code>None</code> instead of raising a <code>KeyError</code>.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data.get('gender'))\n</code></pre> <pre><code>None\n</code></pre> <p>Since <code>gender</code> didn't exist, <code>None</code> was returned. Alternatively, a default value could be provided as second parameter which is returned if key does not exist:</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data.get('name', 'No name'))\nprint(data.get('gender', 'male'))\n</code></pre> <pre><code>John\nmale\n</code></pre> <p>Since <code>name</code> key existed, its value was returned and default <code>No name</code> was ignored. In case of <code>gender</code>, the key didn't exist so default value was returned instead.</p>"},{"location":"data-structures/dictionary/accessing-items/#accessing-keys-and-values","title":"Accessing keys and values","text":"<p>A dictionary provides three methods to access its data:</p>"},{"location":"data-structures/dictionary/accessing-items/#dictkeys","title":"<code>dict.keys()</code>","text":"<p><code>dict.keys()</code> method returns an iterable that contains the dictionary keys.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data.keys())\n</code></pre> <pre><code>dict_keys(['name', 'age'])\n</code></pre>"},{"location":"data-structures/dictionary/accessing-items/#dictvalues","title":"<code>dict.values()</code>","text":"<p>Similarly, <code>dict.values()</code> returns an iterable of values stored in the dictionary.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data.values())\n</code></pre> <pre><code>dict_values(['John', 25])\n</code></pre>"},{"location":"data-structures/dictionary/accessing-items/#dictitems","title":"<code>dict.items()</code>","text":"<p><code>dict.items()</code> returns an iterable that has tuples representing key-value pairs where each tuple has two elements: key and value.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data.items())\n</code></pre> <pre><code>dict_items([('name', 'John'), ('age', 25)])\n</code></pre> <p>Note</p> <p>Do not confuse the returned values of each of these methods with ordinary lists. These methods return a special iterable.</p> <p>It can be indexed and iterated over but cannot be modified.</p>"},{"location":"data-structures/dictionary/accessing-items/#iterating-over-a-dictionary","title":"Iterating over a dictionary","text":"<p>We can iterate over the items of a dictionary using a for loop and <code>dict.items()</code> method.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nfor key, value in data.items():\n    print(f'{key} in data corresponds to {value}')\n</code></pre> <pre><code>name in data corresponds to John\nage in data corresponds to 25\n</code></pre> <p>As we saw earlier in this section, <code>dict.items()</code> returns an iterable of key-value tuples, we are simply looping through those tuples and unpacking the tuple values into <code>key</code> and <code>value</code> variables.</p> <p>Note</p> <p>Simply iterating over a dictionary without calling the <code>dict.items()</code> method loops through only the keys of the dictionary.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nfor x in data:\n    print(x)\n</code></pre> <pre><code>name\nage\n</code></pre>"},{"location":"data-structures/dictionary/introduction/","title":"7.5.1. Basics of Dictionary","text":"<p>Till now, we saw data structures that stored data as a sequence of values that could be retrieved using indexes (except sets).</p> <p>Dictionary is another data structure in Python that is different from the rest in terms of how data is stored by dictionary.</p>"},{"location":"data-structures/dictionary/introduction/#defining-dictionary","title":"Defining Dictionary","text":"<p>In real life, we use often use language dictionaries. Similar to language dictionaries, where each word maps to a specific definition or meaning, Python dictionaries also are mappings that can be used to store data as key-value pairs.</p> <p>Each key in the dictionary maps to a specific value. Comparing this to language dictionaries, key could be seen as the word and value could be seen as its definition.</p> <p>To define a dictionary, we use the <code>{}</code> curly braces. Each key-value pair in the dictionary is separated by a <code>:</code> colon.</p> <pre><code>d1 = {}  # (1)!\nd2 = {'a': 'Apple', 'b': 'Banana', 'm': 'Mango'}  # (2)!\nd3 = {'a': 0, 23: True, 3.14: 'pi'}  # (3)!\n</code></pre> <ol> <li>This is an empty dictionary with no items.</li> <li>This is a dictionary with 4 items, all of same type (str)</li> <li>This is a dictionary with 3 items, of different types.</li> </ol> <p>In above code, we defined three dictionaries: one of them being empty, other storing data of same data type, and the third one storing data of different data types.</p> <p>Note</p> <p>By convention, data in a dictionary are referred to as items instead of elements as for tuples or lists.</p>"},{"location":"data-structures/dictionary/introduction/#accessing-dictionary-items","title":"Accessing Dictionary Items","text":"<p>To access data stored in a dictionary, a syntax similar to indexing is used.</p> CodeOutput <pre><code>person = {\n    'name': 'John',\n    'age': 20,\n    'gender': 'male',\n}\n\nprint(person['age'])\n</code></pre> <pre><code>20\n</code></pre> <p>As you can see that instead of using the indexes, as we did for tuples and lists, we give the key we want to access in the <code>[]</code> brackets. This is the way of accessing data of a dictionary.</p>"},{"location":"data-structures/dictionary/introduction/#basic-features","title":"Basic Features","text":"<p>Dictionaries are different from other data structures such as list and tuples due to the principle difference of how data is stored.</p> <p>Other features of dictionaries are:</p> <ul> <li>Ordered</li> <li>Immutable Keys</li> <li>No Duplicates</li> <li>Nestable</li> <li>Mutable</li> </ul>"},{"location":"data-structures/dictionary/introduction/#ordered","title":"Ordered","text":"<p>Although accessing the data stored in the dictionary is independent of the order, the order in which a dictionary is defined remains the same.</p> <p>Although unlike other structures, the order doesn't matter when comparing dictionaries, the order is still preserved and when printing a dictionary, it will appear in order in which it was defined.</p> CodeOutput <pre><code>person1 = {\n    'name': 'John',\n    'age': 20,\n    'gender': 'male',\n}\n\nperson2 = {\n    'age': 20,\n    'gender': 'male',\n    'name': 'John',\n}\n\nprint(person1)\nprint(person2)\nprint(person1 == person2)\n</code></pre> <pre><code>{'name': 'John', 'age': 20, 'gender': 'male'}\n{'age': 20, 'gender': 'male', 'name': 'John'}\nTrue\n</code></pre>"},{"location":"data-structures/dictionary/introduction/#immutable-keys","title":"Immutable Keys","text":"<p>The keys of the dictionary follow the rules similar to a set. They must be immutable.</p> <p>This means we can't use sets and lists as dictionary keys because those are mutable types.</p> CodeOutput <pre><code>d = {[0, 1]: 'A'}\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"C:\\XGuides\\python\\test.py\", line 1, in &lt;module&gt;\n    d = {[0, 1]: 'A'}\n        ^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'\n</code></pre> <p>However, we can use tuples as dictionary keys since they are immutable.</p> CodeOutput <pre><code>d = {(0, 1): 'A'}\nprint(d[0, 1])\n</code></pre> <pre><code>A\n</code></pre> <p>Note</p> <p>As discussed in sets topic as well, that it would be a half correct or incomplete statement to say that dictionary keys only allow \"immutable types.\"</p> <p>This is true but the actual keys that dictionary allows are \"hashable\" types. Hashable types are those values that can be passed to the <code>hash()</code> function to creates a unique string called \"hash\" that Python uses internally to represent the keys of a dictionary.</p> <p>In other words, dictionary keys does not allow mutable types because they are not hashable.</p> <p>There are no such restrictions on dictionary values as they can store any arbitrary value.</p>"},{"location":"data-structures/dictionary/introduction/#no-duplicates","title":"No Duplicates","text":"<p>Dictionary keys cannot be duplicated. When we define a duplicate key, the old key is replaced with that key.</p> CodeOutput <pre><code>d = {\n    'A': 'Apple',\n    'B': 'Banana',\n    'A': 'Apricot',\n}\nprint(d['A'])\n</code></pre> <pre><code>Apricot\n</code></pre> <p>Dictionary values can be duplicated without any restriction. Two different keys could store a same value.</p>"},{"location":"data-structures/dictionary/introduction/#nestable","title":"Nestable","text":"<p>Dictionaries can be nested similar to lists and tuples. This means we can store a dictionary inside another dictionary.</p> CodeOutput <pre><code>dictionary = {\n    'fruits': {'A': 'Apple', 'B': 'Banana', 'P': 'Pineapple'},\n    'numbers': {0: 'A', 1: 'B', 2: 'C'},\n}\nprint(d['fruits']['B'])\nprint(d['numbers'][1])\n</code></pre> <pre><code>Banana\nB\n</code></pre> <p>Note that nesting is only possible in dictionary values. Keys cannot be dictionaries as discussed earlier since they are mutable types.</p>"},{"location":"data-structures/dictionary/introduction/#mutable","title":"Mutable","text":"<p>Dictionaries, like lists, are mutable. This means the keys can be removed, updated or added after the initial definition of dictionary.</p> <p>We will cover this in section 7.5.2. Dictionaries: Manipulating Items.</p>"},{"location":"data-structures/dictionary/manipulating-items/","title":"7.5.3. Manipulating Items","text":"<p>In this section, we'll see some ways of manipulating the items of a dictionary data structure.</p>"},{"location":"data-structures/dictionary/manipulating-items/#setting-key-values","title":"Setting Key Values","text":"<p>The most basic way of adding an element to a dictionary is by setting the key to its value.</p> CodeOutput <pre><code>data = {}\ndata['name'] = 'John'\ndata['age'] = 25\n\nprint(data)\n</code></pre> <pre><code>{'name': 'John', 'age': 25}\n</code></pre> <p>Note that if the key already exists in the dictionary, its value is updated with the new one.</p> CodeOutput <pre><code>data = {}\n\ndata['name'] = 'John'\ndata['age'] = 25\nprint(data)\n\ndata['name'] = 'Alex'\nprint(data)\n</code></pre> <pre><code>{'name': 'John', 'age': 25}\n{'name': 'Alex', 'age': 25}\n</code></pre>"},{"location":"data-structures/dictionary/manipulating-items/#updating-dictionary","title":"Updating dictionary","text":"<p>A dictionary can be updated with the new one using the <code>dict.update()</code> method. It takes another dictionary which is merged with original one.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\ndata.update({'gender': 'male', 'role': 'Manager'})\nprint(data)\n</code></pre> <pre><code>{'name': 'John', 'age': 25, 'gender': 'male', 'role': 'Manager'}\n</code></pre> <p>If a key in new dictionary already exists in original one, its value in original is updated with new one.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\ndata.update({'gender': 'male', 'name': 'Alex'})\nprint(data)\n</code></pre> <pre><code>{'name': 'Alex', 'age': 25, 'gender': 'male'}\n</code></pre> <p><code>dict.update()</code> can also take any iterable with key value pairs (a sequence with two values, first one being the key and second representing the value).</p> <p>For example, we're passing a list of two key-value pairs here:</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\ndata.update([('gender', 'male'), ('role', 'Manager')])\nprint(data)\n</code></pre> <pre><code>{'name': 'John', 'age': 25, 'gender': 'male', 'role': 'Manager'}\n</code></pre>"},{"location":"data-structures/dictionary/manipulating-items/#deleting-items-del-keyword","title":"Deleting Items (<code>del</code> Keyword)","text":"<p>The <code>del</code> keyword can be used to remove a key from the dictionary.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\ndel data['name']\nprint(data)\n</code></pre> <pre><code>{'age': 25}\n</code></pre> <p>The key must exist. If not, a <code>KeyError</code> is raised.</p>"},{"location":"data-structures/dictionary/manipulating-items/#deleting-items-methods","title":"Deleting Items (Methods)","text":"<p><code>dict.pop()</code> removes an item from the dictionary by its key name and returns the value.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data.pop('age'))\nprint(data)\n</code></pre> <pre><code>25\n{'name': 'John'}\n</code></pre> <p>If the key does not exist, it raises a <code>KeyError</code> unless a default value is provided as second parameter.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data.pop('gender', 'male'))\nprint(data)\n</code></pre> <pre><code>male\n{'name': 'John', 'age': 25}\n</code></pre> <p>Since <code>gender</code> key didn't exist, the default value provided as second parameter was returned instead of raising <code>KeyError</code>.</p> <p>There is also a <code>dict.popitem()</code> that removes the most recently added item. It returns a two-value tuple in which first item is the key removed and second item is the value.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data.popitem())\nprint(data)\n</code></pre> <pre><code>('age', 25)\n{'name': 'John'}\n</code></pre> <p>Note that since <code>age</code> was the last element of dictionary, it was removed.</p> <p>Note</p> <p>In Python versions below 3.7, a random item was removed by this method because dictionaries were not ordered.</p>"},{"location":"data-structures/dictionary/manipulating-items/#clearing-items","title":"Clearing Items","text":"<p><code>dict.clear()</code> method takes the destructive approach and deletes all items from a dictionary.</p> CodeOutput <pre><code>data = {\n    'name': 'John',\n    'age': 25,\n}\n\nprint(data)\n\ndata.clear()\nprint(data)\n</code></pre> <pre><code>{'name': 'John', 'age': 25}\n{}\n</code></pre>"},{"location":"data-structures/lists/introduction/","title":"7.1.1. Basics of Lists","text":"<p>In programming, we need a way of storing and representing large and complex data. This is when data structures come into play.</p> <p>In this chapter, we'll learn about various built-in data structures in Python, starting with lists!</p>"},{"location":"data-structures/lists/introduction/#defining-lists","title":"Defining Lists","text":"<p>Lists are used to store a sequence of values of either same or different data types under a single variable.</p> <p>A list is defined using square brackets <code>[]</code>:</p> <pre><code>l1 = []  # (1)!\nl2 = ['apple', 'banana', 'peach', 'strawberry']  # (2)!\nl3 = ['text', 23, 3.14, 9.20, False]  # (3)!\n</code></pre> <ol> <li>This is an empty list with no elements.</li> <li>This is a list with 4 elements, all of same type (str)</li> <li>This is a list with 5 elements, of different types.</li> </ol> <p>In above code, we defined three lists: one of them being empty, other storing data of same data type, and the third one storing data of different data types.</p> <p>Note</p> <p>If you're using the web browser version of this guide, click on the each <code>+</code> icon in the code to view detail of list defined on that line.</p>"},{"location":"data-structures/lists/introduction/#basic-features","title":"Basic Features","text":"<p>Lists have some characteristic features that distinguish them from other linear data structures provided by the language:</p> <ul> <li>Ordered</li> <li>Indexable</li> <li>Allows Duplicates</li> <li>Nestable</li> <li>Mutable</li> </ul>"},{"location":"data-structures/lists/introduction/#ordered","title":"Ordered","text":"<p>All lists have follow a specific order.</p> CodeOutput <pre><code>a = [1, 2, 3, 4, 5]\nb = [2, 3, 1, 5, 4]\nc = [1, 2, 3, 4, 5]\n\nprint(a == b)\nprint(c == a)\n</code></pre> <pre><code>False\nTrue\n</code></pre> <p>In this code, <code>a</code> and <code>b</code> lists have similar elements but they don't have the same order so two lists are not equal. <code>a</code> and <code>c</code> on the other hand, have similar elements with same order so the two lists are equal.</p>"},{"location":"data-structures/lists/introduction/#indexable","title":"Indexable","text":"<p>Each element stored in a list can be accessed by its index. We learned about indexes in section 4.1. Indexing Strings.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach', 'strawberry']\n\nprint(fruits[2])\n</code></pre> <pre><code>peach\n</code></pre> <p>All the rules about indexes we saw in section 4.1. Indexing Strings are applicable on lists too:</p> <p>Indexes start from <code>0</code> (<code>0</code> pointing to first element) and negative indexes starting from <code>-1</code> can be used to access elements from right hand side.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach', 'strawberry']\n\nprint(fruits[-3])\n</code></pre> <pre><code>banana\n</code></pre> <p>Since list elements are represented by indexes, this also means that lists can be sliced similar to strings.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach', 'strawberry']\n\nprint(fruits[0:3])\n</code></pre> <pre><code>['apple', 'banana', 'peach']\n</code></pre> <p><code>list[n:m]</code> returns a new list starting from element on <code>n</code> index in original <code>list</code> up until element on <code>m - 1</code> index (upper bound is exclusive).</p> <p>For more information on slicing, see section 4.2. Slicing Strings.</p>"},{"location":"data-structures/lists/introduction/#allows-duplicates","title":"Allows Duplicates","text":"<p>Lists allow duplicate elements to be stored.</p> CodeOutput <pre><code>fruits = [\n    'apple',\n    'peach',\n    'banana',\n    'peach',\n    'strawberry',\n    'peach',\n    'apple'\n]\n\nprint(fruits)\n</code></pre> <pre><code>['apple', 'peach', 'banana', 'peach', 'strawberry', 'peach', 'apple']\n</code></pre> <p>In this case, <code>fruits[0]</code> and <code>fruits[6]</code> are duplicates and <code>fruits[1]</code>, <code>fruits[3]</code> and <code>fruits[5]</code> are duplicates.</p>"},{"location":"data-structures/lists/introduction/#nestable","title":"Nestable","text":"<p>Lists can be nested. This means we can store a list inside another list.</p> CodeOutput <pre><code>l = [\n    [0, 1, 2],\n    ['a', 'b', 'c'],\n]\n\nprint(l[1][2])\n</code></pre> <pre><code>c\n</code></pre> <p>In this code, we're first accessing the second element of <code>l</code> which is in turn another list <code>['a', 'b', 'c']</code> then we're indexing the second list accessing the third element.</p> <p>There is no restriction on how deep we can go with nesting:</p> CodeOutput <pre><code>l = [\n        [0, 1, 2],\n        [\n            'a', 'b',\n            ['c', 'd'],\n        ],\n    ]\n\n    print(l[1][1][0])\n</code></pre> <pre><code>c\n</code></pre> <p>Undoubtedly this code looks tedious and confusing but we're simply storing two lists in <code>l</code> and the second list has another list nested in it.</p>"},{"location":"data-structures/lists/introduction/#mutable","title":"Mutable","text":"<p>Lists is a mutable data structure. This means the items in a list can be updated after the list has been defined initially.</p> <p>We'll see how lists are updated and modified in the later section.</p> <p>Note</p> <p>Up until now, we had only seen immutable types that could not be modified once created. For example, integers, strings, floats and booleans are all immutable types whose value cannot be changed after definition.</p> <p>Lists is the first mutable type that we're discussing in this guide with many more to come in sections ahead.</p>"},{"location":"data-structures/lists/manipulating-elements/","title":"7.1.2. Manipulating Elements","text":"<p>Data stored in a list can be modified after list has been initially defined. Let us have a look at some ways of doing that.</p>"},{"location":"data-structures/lists/manipulating-elements/#replacing-single-element","title":"Replacing Single Element","text":"<p>Elements in a list can be replaced using the indexes.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach', 'strawberry']\nprint('before:', fruits)\n\nfruits[1] = 'grapes'\nprint('after:', fruits)\n</code></pre> <pre><code>before: ['apple', 'banana', 'peach', 'strawberry']\nafter: ['grapes', 'banana', 'peach', 'strawberry']\n</code></pre> <p>Note that it isn't possible to add additional elements using indexes:</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach', 'strawberry']\nprint('before:', fruits)\n\nfruits[4] = 'grapes'\nprint('after:', fruits)\n</code></pre> <pre><code>before: ['apple', 'banana', 'peach', 'strawberry']\nTraceback (most recent call last):\n  File \"C:\\XGuides\\python\\test.py\", line 4, in &lt;module&gt;\n    fruits[4] = 'grapes'\n    ~~~~~~^^^\nIndexError: list assignment index out of range\n</code></pre> <p>Since list only has four elements, maximum index is 3 and we're trying to assign to 4th index which isn't allowed.</p>"},{"location":"data-structures/lists/manipulating-elements/#replacing-multiple-elements","title":"Replacing Multiple Elements","text":"<p>It is also possible to replace multiple elements using slices:</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach', 'strawberry', 'mango', 'grapes']\nprint('before:', fruits)\n\nfruits[1:4] = ['BANANA', 'PEACH', 'STRAWBERRY']\nprint('after:', fruits)\n</code></pre> <pre><code>before: ['apple', 'banana', 'peach', 'strawberry']\nafter: ['apple', 'BANANA', 'PEACH', 'STRAWBERRY', 'mango', 'grapes']\n</code></pre> <p>Again, the upper bound is exclusive in this case so in order to replace elements from index 1 to index 3, we have to provide <code>1:4</code>.</p> <p>Note however that it isn't necessarily important for list being replaced to be of same size as provided index range. Additional elements are adjusted automatically:</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach', 'strawberry', 'mango', 'grapes']\nprint('before:', fruits)\n\nfruits[1:4] = ['BANANA', 'PEACH', 'STRAWBERRY', 'WATERMELON']\nprint('after:', fruits)\n</code></pre> <pre><code>before: ['apple', 'banana', 'peach', 'strawberry']\nafter: ['apple', 'BANANA', 'PEACH', 'STRAWBERRY', 'WATERMELON', 'mango', 'grapes']\n</code></pre> <p>In this case, <code>WATERMELON</code> was the additional element.</p>"},{"location":"data-structures/lists/manipulating-elements/#adding-elements-operator","title":"Adding Elements (<code>+</code> operator)","text":"<p>Elements can be added to the list in various ways.</p> <p>First way is by concatenating lists. Two lists can be added such that the elements of second list (the one on right of <code>+</code> operator) are appended to the first list.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach']\nnew_fruits = fruits + ['strawberry', 'mango']\n\nprint(new_fruits)\n</code></pre> <pre><code>['apple', 'banana', 'peach', 'strawberry', 'mango']\n</code></pre> <p>A new list is created everytime <code>+</code> is used between two lists.</p>"},{"location":"data-structures/lists/manipulating-elements/#adding-elements-methods","title":"Adding Elements (methods)","text":"<p>Other ways of adding elements is using the methods provided by list data type: <code>list.append()</code>, <code>list.extend()</code> and <code>list.insert()</code>.</p>"},{"location":"data-structures/lists/manipulating-elements/#listextend","title":"<code>list.extend()</code>","text":"<p><code>list.extend()</code> is essentially same as using the <code>+</code> operator.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach']\nfruits.extend(['strawberry', 'mango'])\n\nprint(fruits)\n</code></pre> <pre><code>['apple', 'banana', 'peach', 'strawberry', 'mango']\n</code></pre> <p>One caveat about <code>.extend()</code> is that passed argument isn't necessarily supposed to be a list. It could be any iterable, even a string too. This isn't the case in using <code>+</code> operator.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach']\nfruits.extend('mango')\n\nprint(fruits)\n</code></pre> <pre><code>['apple', 'banana', 'peach', 'm', 'a', 'n', 'g', 'o']\n</code></pre> <p>Another thing to note is that <code>+</code> creates a new list with updated elements while <code>.extend()</code> updates the old list instead of creating new one. This is called in-place update operation.</p>"},{"location":"data-structures/lists/manipulating-elements/#listappend","title":"<code>list.append()</code>","text":"<p><code>list.append()</code> on the other hand is used to add singular elements to the end of list.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach']\n\nfruits.append('mango')\nprint('appended mango:', fruits)\n\nfruits.append('strawberry')\nprint('appended strawberry:', fruits)\n</code></pre> <pre><code>appended mango: ['apple', 'banana', 'peach', 'mango']\nappended strawberry: ['apple', 'banana', 'peach', 'mango', 'strawberry']\n</code></pre>"},{"location":"data-structures/lists/manipulating-elements/#listinsert","title":"<code>list.insert()</code>","text":"<p>Finally, we have <code>list.insert()</code> method which is used to insert elements at a specific index.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach']\n\nfruits.insert(0, 'mango')\nprint('insert mango at start:', fruits)\n\nfruits.insert(2, 'strawberry')\nprint('insert strawberry at index 2:', fruits)\n</code></pre> <pre><code>insert mango at start: ['mango', 'apple', 'banana', 'peach']\ninsert strawberry at index 2: ['mango', 'apple', 'strawberry', 'banana', 'peach']\n</code></pre>"},{"location":"data-structures/lists/manipulating-elements/#removing-elements-del","title":"Removing Elements (<code>del</code>)","text":"<p>List elements can be removed using their indexes using the <code>del</code> keyword.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach']\nprint('before:', fruits)\n\ndel fruits[1]\nprint('after:', fruits)\n</code></pre> <pre><code>before: ['apple', 'banana', 'peach']\nafter: ['apple', 'peach']\n</code></pre> <p>Note</p> <p>The <code>del</code> keyword is used to delete any object in Python. If we use <code>del</code> on a variable, that variable is deleted.</p> <pre><code>a = 1\ndel a\nprint(a)  # NameError: 'a' is not defined\n</code></pre>"},{"location":"data-structures/lists/manipulating-elements/#removing-elements-methods","title":"Removing Elements (methods)","text":"<p>The <code>list</code> data type provides many methods that can be used to remove elements from a list.</p>"},{"location":"data-structures/lists/manipulating-elements/#listpop","title":"<code>list.pop()</code>","text":"<p><code>list.pop()</code> works in a similar way as the <code>del</code> operator: it removes the element using its index. The only difference is that the removed element is also returned by this method.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach']\nprint('before:', fruits)\n\nremoved = fruits.pop(1)\nprint(f'after removing {removed}:', fruits)\n</code></pre> <pre><code>before: ['apple', 'banana', 'peach']\nafter removing banana: ['apple', 'peach']\n</code></pre> <p><code>fruits.pop(1)</code> returned the removed element, <code>'banana'</code>.</p> <p>If no argument is passed in <code>list.pop()</code>, the last element of the list (from right hand side) is removed:</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach']\nprint('before:', fruits)\n\nremoved = fruits.pop()\nprint(f'after removing {removed}:', fruits)\n</code></pre> <pre><code>before: ['apple', 'banana', 'peach']\nafter removing peach: ['apple', 'banana']\n</code></pre>"},{"location":"data-structures/lists/manipulating-elements/#listremove","title":"<code>list.remove()</code>","text":"<p><code>list.remove()</code> takes any value as parameter and removes that value from the list:</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach']\nprint('before:', fruits)\n\nfruits.remove('banana')\nprint(f'after:', fruits)\n</code></pre> <pre><code>before: ['apple', 'banana', 'peach']\nafter: ['apple', 'peach']\n</code></pre> <p>Worth noting that if the given value appears more than once in the list, only the first occurence is removed:</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach', 'banana']\nprint('before:', fruits)\n\nfruits.remove('banana')\nprint(f'after:', fruits)\n</code></pre> <pre><code>before: ['apple', 'banana', 'peach', 'banana']\nafter: ['apple', 'peach', 'banana']\n</code></pre> <p>In case the passed value is not in the list, a <code>ValueError</code> is raised.</p>"},{"location":"data-structures/lists/manipulating-elements/#listclear","title":"<code>list.clear()</code>","text":"<p><code>list.clear()</code> is a rather nuclear option. This method deletes all elements of the list and makes it empty.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach']\nprint('before:', fruits)\n\nfruits.clear()\nprint(f'after:', fruits)\n</code></pre> <pre><code>before: ['apple', 'banana', 'peach', 'banana']\nafter: []\n</code></pre>"},{"location":"data-structures/sets/introduction/","title":"7.3.1. Basics of Sets","text":"<p>Sets are one of the four built-in data structures that we'll study in this guide.</p>"},{"location":"data-structures/sets/introduction/#defining-sets","title":"Defining Sets","text":"<p>Like lists and tuples, set is also a data structure that stores values in a single variable but there are two main differences between the sets and lists or tuples:</p> <ul> <li>Sets are unordered</li> <li>Sets don't allow duplicates</li> </ul> <p>We'll discuss these differnces later in this section.</p> <p>In order to define a set, we have to enclose the set elements in <code>{}</code> curly braces. Note that in order to define an empty set, we cannot use <code>{}</code> but instead the <code>set()</code> function.</p> <pre><code>s1 = set()  # (1)!\ns2 = {'apple', 'banana', 'peach', 'strawberry'}  # (2)!\ns3 = {'text', 23, 3.14, 9.20, False}  # (3)!\n</code></pre> <ol> <li>This is an empty set with no elements.</li> <li>This is a set with 4 elements, all of same type (str)</li> <li>This is a set with 5 elements, of different types.</li> </ol> <p>In above code, we defined three sets: one of them being empty, other storing data of same data type, and the third one storing data of different data types.</p> <p>Empty set definition</p> <p>The reason why we use <code>set()</code> instead of <code>{}</code> for defining empty sets is because <code>{}</code> are also used to represent dictionaries so it becomes ambiguous on what is being defined.</p>"},{"location":"data-structures/sets/introduction/#basic-features","title":"Basic Features","text":"<p>Following are the features of set that differentiate it from other data structures e.g. lists and tuples.</p> <ul> <li>Unordered</li> <li>Unindexable</li> <li>No Duplicates</li> <li>No mutable types</li> </ul> <p>Note</p> <p>Like lists and tuples, sets are mutable.</p>"},{"location":"data-structures/sets/introduction/#unordered","title":"Unordered","text":"<p>Sets do not follow a specific order. This can be seen when printing sets:</p> <pre><code>s1 = {'a', 'b', 'c', 'd', 'e', 'f'}\nprint(s1)\n</code></pre> <p>If you run the above program multiple times, you'll notice that set is printed with different order almost everytime you run the program.</p> CodeOutput <pre><code>s1 = {'a', 'b', 'c'}\ns2 = {'b', 'c', 'a'}\nprint(s1 == s2)\n</code></pre> <pre><code>True\n</code></pre> <p>Despite defining the set with seemingly different order, the result of this comparison is <code>True</code> because both sets have similar elements.</p> <p>This is contrary to what happened in case of lists and tuples.</p>"},{"location":"data-structures/sets/introduction/#unindexable","title":"Unindexable","text":"<p>Because sets don't have any order. They cannot be indexed.</p> <p>This means elements of a set cannot be accessed or replaced like lists or tuples.</p> CodeError <pre><code>s1 = {'a', 'b', 'c'}\nprint(s1[0])\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"C:\\XGuides\\python\\test.py\", line 2, in &lt;module&gt;\n    print(s1[0])\n          ~~^^^\nTypeError: 'set' object is not subscriptable\n</code></pre> <p>This also means that sets cannot be sliced.</p>"},{"location":"data-structures/sets/introduction/#no-duplicates","title":"No Duplicates","text":"<p>Sets do not allow duplicates. If you define a set with duplicate elements, the duplicates are automatically ignored or discarded.</p> CodeOutput <pre><code>s1 = {'a', 'b', 'c', 'a'}\nprint(s1)\n</code></pre> <pre><code>{'a', 'b', 'c'}\n</code></pre>"},{"location":"data-structures/sets/introduction/#no-mutable-types","title":"No mutable types","text":"<p>For lists and tuples, we could store mutable types in it. For example, we could store a tuple inside a list and vice versa but this isn't the case for sets.</p> <p>Sets do not allow storing mutable types in it.</p> CodeOutput <pre><code>s = {'a', [1, 2, 3]}\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"C:\\XGuides\\python\\test.py\", line 1, in &lt;module&gt;\n    s = {'a', [1, 2, 3]}\n        ^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'\n</code></pre> <p>Since tuples are immutable, they can be stored in sets.</p> <p>Note</p> <p>Technically speaking, it would be a half correct or incomplete statement to say that sets only allow \"immutable types.\"</p> <p>This is true but the actual items that set allows is \"hashable\" types. Hashable types are those values that can be passed to the <code>hash()</code> function to creates a unique string called \"hash\" that Python uses internally to represent the items of a set.</p> <p>In other words, set does not allow mutable types because they are not hashable.</p>"},{"location":"data-structures/sets/introduction/#application","title":"Application","text":"<p>With sets being unordered and unindexable, this raises a question that how are sets useful compared to lists and tuples?</p> <p>Lists and tuples allow the stored data to be accessed while set on the other hand, does not allow this.</p> <p>Lists and tuples are used to store data and access it later while sets are generally used to eliminate duplicates or perform mathematical set operations on data such as union, difference and intersection.</p> <p>We'll discuss this in later sections.</p>"},{"location":"data-structures/sets/manipulating-elements/","title":"7.3.2. Manipulating Elements","text":"<p>Sets are mostly used for mathematical operations instead of storing data for later use as is the case for tuples and list. Due to this, set only provides a small set of operations to manipulate its elements.</p>"},{"location":"data-structures/sets/manipulating-elements/#adding-elements-setadd-method","title":"Adding Elements (<code>set.add()</code> method)","text":"<p><code>set.add()</code> can be used to add elements to a set.</p> CodeOutput <pre><code>s1 = {'a', 'b', 'c'}\ns1.add('d')\nprint(s1)\n</code></pre> <pre><code>{'a', 'b', 'c', 'd'}\n</code></pre> <p>Note</p> <p>Keep in mind that order of elements isn't fixed and duplicates are not allowed in sets.</p> <p>There are other operations that can be used to add elements such as union operation which are covered in later section.</p>"},{"location":"data-structures/sets/manipulating-elements/#removing-elements-with-setpop","title":"Removing Elements with <code>set.pop()</code>","text":"<p><code>set.pop()</code> can be used to remove a random element from the set. It returns the removed element.</p> CodeOutput <pre><code>s1 = {'a', 'b', 'c'}\nprint(s1.pop())\nprint(s1)\n</code></pre> <pre><code>b\n{'a', 'c'}\n</code></pre> <p>Unlike <code>list.pop()</code>, this method does not remove element in a fixed order and doesn't take any index since sets are not indexable.</p> <p>Everytime the program is run, a different or random element is popped.</p> <p>If set is empty, a <code>KeyError</code> is raised.</p>"},{"location":"data-structures/sets/manipulating-elements/#removing-elements-with-setremove","title":"Removing Elements with <code>set.remove()</code>","text":"<p><code>set.remove()</code> removes the given item from set.</p> CodeOutput <pre><code>s1 = {'a', 'b', 'c'}\ns1.remove('a')\nprint(s1)\n</code></pre> <pre><code>{'b', 'c'}\n</code></pre> <p><code>set.remove()</code> raises a <code>KeyError</code> if item is not found in the set.</p>"},{"location":"data-structures/sets/manipulating-elements/#removing-all-elements","title":"Removing all elements","text":"<p>A set can be emptied using the <code>set.clear()</code> methods which deletes all the elements from the set.</p> CodeOutput <pre><code>s1 = {'a', 'b', 'c'}\ns1.clear()\nprint(s1)\n</code></pre> <pre><code>set()\n</code></pre> <p>Note</p> <p><code>set()</code> implies empty set.</p>"},{"location":"data-structures/sets/set-operations/","title":"7.3.3. Set Operations","text":"<p>Sets are generally used for operations similar to mathematical sets like union, intersection, and difference, etc.</p>"},{"location":"data-structures/sets/set-operations/#union","title":"Union","text":"<p>Union of two sets <code>x</code> and <code>y</code> produces a new set with elements of both <code>x</code> and <code>y</code>.</p> <p>For this, we can either use the <code>|</code> operator.</p> CodeOutput <pre><code>x = {'a', 'b', 'c'}\ny = {'c', 'd', 'e', 'f'}\nz = x | y\nprint(z)\n</code></pre> <pre><code>{'a', 'b', 'c', 'd', 'e', 'f'}\n</code></pre> <p>or we can use the <code>set.union()</code> method:</p> CodeOutput <pre><code>x = {'a', 'b', 'c'}\ny = {'c', 'd', 'e', 'f'}\nz = x.union(y)\nprint(z)\n</code></pre> <pre><code>{'a', 'b', 'c', 'd', 'e', 'f'}\n</code></pre> <p>As seen here, union combines the two sets. Note that since sets don't allow duplicates, the <code>\"c\"</code> which was in both sets appears only once.</p> <p><code>|</code> vs <code>set.union()</code></p> <p><code>|</code> and <code>set.union()</code> operates the same way except one caveat: we can pass any sequence in <code>set.union()</code> like list or tuple which isn't the case for <code>|</code> operator.</p> <p>We also have <code>set.update()</code> which instead of creating new set, updates the original set.</p> CodeOutput <pre><code>x = {'a', 'b', 'c'}\ny = {'c', 'd', 'e', 'f'}\nx.update(y)\nprint(x)\n</code></pre> <pre><code>{'a', 'b', 'c', 'd', 'e', 'f'}\n</code></pre>"},{"location":"data-structures/sets/set-operations/#intersection","title":"Intersection","text":"<p>Intersection of two sets <code>x</code> and <code>y</code> produces a new set with elements that are common in both <code>x</code> and <code>y</code>.</p> <p><code>&amp;</code> operator is used for intersection of two sets:</p> CodeOutput <pre><code>x = {'a', 'b', 'c', 'd'}\ny = {'c', 'd', 'e', 'f'}\nz = x &amp; y\nprint(z)\n</code></pre> <pre><code>{'c', 'd'}\n</code></pre> <p>Alternatively, set provides a <code>set.intersection()</code> method:</p> CodeOutput <pre><code>x = {'a', 'b', 'c', 'd'}\ny = {'c', 'd', 'e', 'f'}\nz = x.intersection(y)\nprint(z)\n</code></pre> <pre><code>{'c', 'd'}\n</code></pre> <p><code>&amp;</code> vs <code>set.intersection()</code></p> <p><code>|</code> and <code>set.intersection()</code> do the same thing but <code>set.intersection()</code> allows other sequences to be passed such as list or tuple.</p> <p>Similar to <code>set.update()</code>, we can use <code>set.intersection_update()</code> that updates the original set instead of creating a new one.</p> CodeOutput <pre><code>x = {'a', 'b', 'c', 'd'}\ny = {'c', 'd', 'e', 'f'}\nx.intersection_update(y)\nprint(x)\n</code></pre> <pre><code>{'c', 'd'}\n</code></pre>"},{"location":"data-structures/sets/set-operations/#difference","title":"Difference","text":"<p>Difference of sets <code>x</code> and <code>y</code> returns a new set with elements that are present in <code>x</code> but not in <code>y</code>.</p> <p><code>-</code> operator is used for finding difference between two sets:</p> CodeOutput <pre><code>x = {'a', 'b', 'c', 'd'}\ny = {'c', 'd', 'e', 'f'}\nz = x - y\nprint(z)\n</code></pre> <pre><code>{'a', 'b'}\n</code></pre> <p>Set also provides a <code>set.difference()</code> method:</p> CodeOutput <pre><code>x = {'a', 'b', 'c', 'd'}\ny = {'c', 'd', 'e', 'f'}\nz = x.difference(y)\nprint(z)\n</code></pre> <pre><code>{'a', 'b'}\n</code></pre> <p><code>-</code> vs <code>set.difference()</code></p> <p><code>-</code> and <code>set.difference()</code> both calculate the difference but <code>set.difference()</code> allows other sequences to be passed as parameter such as list or tuple.</p> <p>Similar to previous operations, we can use <code>set.difference_update()</code> that updates the original set instead of creating a new one.</p> CodeOutput <pre><code>x = {'a', 'b', 'c', 'd'}\ny = {'c', 'd', 'e', 'f'}\nx.difference_update(y)\nprint(x)\n</code></pre> <pre><code>{'a', 'b'}\n</code></pre>"},{"location":"data-structures/sets/set-operations/#symmetric-difference","title":"Symmetric Difference","text":"<p>Symmetric difference of sets <code>x</code> and <code>y</code> returns a new set with all elements that are present in either <code>x</code> or <code>y</code> but not both.</p> <p>In simpler words, elements that are in both sets are excluded in new set.</p> <p><code>^</code> operator is used for finding symmetric difference between two sets:</p> CodeOutput <pre><code>x = {'a', 'b', 'c', 'd'}\ny = {'c', 'd', 'e', 'f'}\nz = x ^ y\nprint(z)\n</code></pre> <pre><code>{'a', 'b', 'e', 'f'}\n</code></pre> <p>Set also provides a <code>set.symmetric_difference()</code> method:</p> CodeOutput <pre><code>x = {'a', 'b', 'c', 'd'}\ny = {'c', 'd', 'e', 'f'}\nz = x.symmetric_difference(y)\nprint(z)\n</code></pre> <pre><code>{'a', 'b', 'e', 'f'}\n</code></pre> <p><code>^</code> vs <code>set.symmetric_difference()</code></p> <p><code>^</code> and <code>set.symmetric_difference()</code> both calculate the difference but <code>set.symmetric_difference()</code> allows other sequences to be passed as parameter such as list or tuple.</p> <p>Similar to previous operations, we can use <code>set.symmetric_difference_update()</code> that updates the original set instead of creating a new one.</p> CodeOutput <pre><code>x = {'a', 'b', 'c', 'd'}\ny = {'c', 'd', 'e', 'f'}\nx.symmetric_difference_update(y)\nprint(x)\n</code></pre> <pre><code>{'a', 'b', 'e', 'f'}\n</code></pre>"},{"location":"data-structures/sets/set-operations/#disjoint","title":"Disjoint","text":"<p><code>x</code> and <code>y</code> are disjoint sets if they have no elements in common.</p> <p>This is checked using the <code>set.isdisjoint()</code> method. <code>x.isdisjoint(y)</code> returns True if <code>x</code> and <code>y</code> have no elements in common:</p> CodeOutput <pre><code>x = {'a', 'b', 'c'}\ny = {'d', 'e', 'f'}\nprint(x.isdisjoint(y))\n</code></pre> <pre><code>True\n</code></pre> <p>Note</p> <p>There is no operator available for <code>set.disjoint()</code>.</p>"},{"location":"data-structures/sets/set-operations/#subset","title":"Subset","text":"<p><code>x</code> is a subset of <code>y</code> if <code>y</code> contains all elements of <code>x</code>.</p> <p><code>x.issubset(y)</code> returns <code>True</code> if <code>x</code> is a subset of <code>y</code>.</p> CodeOutput <pre><code>x = {'a', 'b', 'c'}\ny = {'a', 'b', 'c', 'd', 'e'}\nprint(x.issubset(y))\n</code></pre> <pre><code>True\n</code></pre> <p><code>&lt;=</code> operator can also be used for checking subset. <code>x &lt;= y</code> is equivalent to <code>x.issubset(y)</code>.</p> <p><code>&lt;=</code> vs <code>set.issubset()</code></p> <p><code>&lt;=</code> and <code>set.issubset()</code> both are same in terms of behaviour with <code>set.issubset()</code> also allowing other sequences to be passed such as list or tuple.</p> <p>Proper Subset</p> <p>X is a proper subset of Y if X contains all elements of Y and X and Y are not equal sets.</p> <p>To report proper subsets, <code>x &lt; y</code> operation is used.</p> <pre><code>x = {'a', 'b', 'c'}\ny = {'a', 'b', 'c', 'd'}\nz = {'a', 'b', 'c'}\n\nprint(x &lt;= y)  # True (x is a subset of y)\nprint(x &lt; y)  # True (x is a proper subset of y)\nprint(x &lt;= z)  # True (x is a subset of z)\nprint(x &lt; z)  # False (x is not a proper subset of z)\n</code></pre> <p>There is no specific method for reporting proper subset.</p>"},{"location":"data-structures/sets/set-operations/#superset","title":"Superset","text":"<p><code>x</code> is a superset of <code>y</code> if <code>x</code> contains all elements of <code>y</code>.</p> <p><code>x.issuperset(y)</code> returns <code>True</code> if <code>x</code> is a superset of <code>y</code>.</p> CodeOutput <pre><code>x = {'a', 'b', 'c', 'd', 'e'}\ny = {'a', 'b', 'c'}\nprint(x.issuperset(y))\n</code></pre> <pre><code>True\n</code></pre> <p>For this method, <code>&gt;=</code> operator is used. <code>x &gt;= y</code> is equivalent to <code>x.issuperset(y)</code>.</p> <p><code>&gt;=</code> vs <code>set.issuperset()</code></p> <p><code>&gt;=</code> and <code>set.issuperset()</code> both are same in terms of behaviour with <code>set.issuperset()</code> also allowing other sequences to be passed such as list or tuple.</p> <p>Proper Superset</p> <p>X is a proper superset of Y if X contains all elements of Y and X and Y are not equal.</p> <p><code>x &gt; y</code> operation can be used to check for proper superset.</p> <pre><code>x = {'a', 'b', 'c', 'd'}\ny = {'a', 'b', 'c'}\nz = {'a', 'b', 'c', 'd'}\n\nprint(x &gt;= y)  # True (x is a superset of y)\nprint(x &gt; y)  # True (x is a proper subset of y)\nprint(x &gt;= z)  # True (x is a subset of z)\nprint(x &gt; z)  # False (x is not a proper subset of z)\n</code></pre> <p>There is no specific method for reporting proper superset.</p> <p>Learn about sets</p> <p>To understand the operations shown more thoroughly, consider checking out the following pages:</p> <ul> <li>Wikipedia: Set Basic Operations</li> <li>Wikipedia: Subset &amp; Superset</li> </ul>"},{"location":"data-structures/tuples/introduction/","title":"7.2.1. Introduction to Tuples","text":"<p>In previous section, we learned about List data structure. This section will cover the <code>tuple</code> data structure.</p>"},{"location":"data-structures/tuples/introduction/#defining-tuples","title":"Defining Tuples","text":"<p>Tuples are linear data structures that can be used to store multiple values in a linear order under single variable, much like lists. The only difference is that tuples are immutable.</p> <p>A tuple can simply be defined using parantheses <code>()</code>:</p> <pre><code>t1 = ()  # (1)!\nt2 = ('apple', 'banana', 'strawberry', 'melon')  # (2)!\nt3 = ('string', 45, 6.28, 9.20, True)  # (3)!\n</code></pre> <ol> <li>This is an empty tuple with no elements.</li> <li>This is a tuple with 4 elements, all of same type (str)</li> <li>This is a tuple with 5 elements, of different types.</li> </ol> <p>In above code, we defined three tuples: one of them being empty, other storing data of same data type, and the third one storing data of different data types.</p> <p>When defining a tuple, the parantheses are only required when defining an empty tuple. Otherwise, the parantheses can be omitted:</p> <pre><code>empty = ()  # (1)!\nfruits = 'apple', 'banana', 'strawberry'  # (2)!\n</code></pre> <ol> <li>Parantheses are only required when defining empty tuple.</li> <li>Parantheses can be omitted when defining non-empty tuples.</li> </ol> <p>Tip</p> <p>Although it is possible to omit parantheses, it is generally considered a good code practice to use parantheses when defining tuples.</p> <p>Defining single element tuples</p> <p>Be careful when defining tuple that has single element. If a tuple has a single element, a comma must be appended to the end of tuple to define a tuple.</p> CodeOutput <pre><code>t1 = ('hello')\nt2 = ('hello',)\n\nprint('t1 is a', type(t1))\nprint('t2 is a', type(t2))\n</code></pre> <pre><code>t1 is a &lt;class 'str'&gt;\nt2 is a &lt;class 'tuple'&gt;\n</code></pre> <p>As seen in above code, omitting the comma creates a string instead of tuple as intended.</p>"},{"location":"data-structures/tuples/introduction/#basic-features","title":"Basic Features","text":"<p>Following are the features of tuple data structure that differentiate it from other data structures:</p> <ul> <li>Immutable</li> <li>Ordered</li> <li>Indexable</li> <li>Allows Duplicates</li> <li>Nestable</li> </ul>"},{"location":"data-structures/tuples/introduction/#immutable","title":"Immutable","text":"<p>Tuples are much like lists: they are linear data structure (sequence) and allows storing multiple items under single variable but with one main difference, tuples are immutable.</p> <p>This means that a tuple cannot be modified once it is created, unlike lists that allow manipulating the elements  after creation.</p> <p>Apart from that, tuples have similar features as a list:</p> <ul> <li>Ordered</li> <li>Indexable</li> <li>Allows Duplicates</li> </ul>"},{"location":"data-structures/tuples/introduction/#ordered","title":"Ordered","text":"<p>Similar to lists, tuples follow specific order.</p> CodeOutput <pre><code>a = (1, 2, 3, 4, 5)\nb = (2, 3, 1, 5, 4)\nc = (1, 2, 3, 4, 5)\n\nprint(a == b)\nprint(c == a)\n</code></pre> <pre><code>False\nTrue\n</code></pre> <p>In this code, <code>a</code> and <code>b</code> tuples have similar elements but they don't have the same order so the two are not equal. <code>a</code> and <code>c</code> on the other hand, have similar elements with same order so they are equal.</p>"},{"location":"data-structures/tuples/introduction/#indexable","title":"Indexable","text":"<p>The elements of a tuple can be accessed using indexes.</p> CodeOutput <pre><code>fruits = ('apple', 'banana', 'peach', 'strawberry')\n\nprint(fruits[2])\n</code></pre> <pre><code>peach\n</code></pre> <p>Tuples support all features of indexes that we saw in section 4.1. Indexing Strings as well as slicing.</p> CodeOutput <pre><code>fruits = ['apple', 'banana', 'peach', 'strawberry']\n\nprint(fruits[-3])  # (1)!\nprint(fruits[0:3])  # (2)!\n</code></pre> <ol> <li> <p>Indexes start from <code>0</code> (<code>0</code> pointing to first element) and negative    indexes    starting from <code>-1</code> can be used to access elements from right    hand side.</p> </li> <li> <p>Tuples can be sliced    to select multiple elements from it.</p> </li> </ol> <pre><code>banana\n['apple', 'banana', 'peach']\n</code></pre>"},{"location":"data-structures/tuples/introduction/#allows-duplicates","title":"Allows Duplicates","text":"<p>Tuples allows duplicate elements.</p> <pre><code>fruits = ('apple', 'pineapple', 'peach', 'strawberry', 'apple', 'peach')\n</code></pre> <p>In this code, <code>fruits[0]</code> and <code>fruits[4]</code> are duplicates and <code>fruits[2]</code> and <code>fruits[5]</code> are duplicates.</p>"},{"location":"data-structures/tuples/introduction/#nestable","title":"Nestable","text":"<p>Tuples can be nested just like lists. This means we can store a tuple inside another tuple.</p> CodeOutput <pre><code>t = (\n    (0, 1, 2),\n    ('a', 'b', 'c'),\n)\n\nprint(t[1][2])\n</code></pre> <pre><code>c\n</code></pre> <p>In this code, we're first accessing the second element of <code>t</code> which is in turn another tuple <code>('a', 'b', 'c')</code> then we're indexing the second tuple accessing the third element.</p> <p>Again, there is no restriction on how deep nesting can be done.</p>"},{"location":"data-structures/tuples/manipulating-elements/","title":"7.2.2. Manipulating Elements","text":"<p>A tuple on its own is immutable meaning once it is created, the elements of it cannot be modified directly.</p> <p>There are some other ways of indirectly acheiving this behaviour which will be discussed in this section.</p>"},{"location":"data-structures/tuples/manipulating-elements/#list-type-casting","title":"List type casting","text":"<p>Tuples can be converted to a list using the <code>list</code> function on the tuple.  This type casts the tuple into a list which can be manipulated and then reconverted into a tuple with a similar method:</p> CodeOutput <pre><code>fruits = ('apple', 'banana', 'peach')\n\n# convert fruits tuple to a list\nfruits = list(fruits)\n\n# modify elements (e.g. add new element)\nfruits.append('strawberry')\n\n# convert back to tuple\nfruits = tuple(fruits)\n\n# output new tuple\nprint(fruits)\n</code></pre> <pre><code>('apple', 'banana', 'peach', 'strawberry')\n</code></pre> <p>In order to remove elements, methods like <code>list.pop()</code> or the <code>del</code> keyword could be used. For more information about list operations, see section 7.1.2. Lists: Manipulating Elements.</p>"},{"location":"data-structures/tuples/manipulating-elements/#concatenating-elements-the-operator","title":"Concatenating elements (the <code>+</code> operator)","text":"<p>Two or more tuples can be concatenated using the <code>+</code> operator.</p> CodeOutput <pre><code>fruits = ('apple', 'banana', 'peach')\nprint(fruits)\n\nfruits = fruits + ('strawberry', 'pineapple')\nprint(fruits)\n</code></pre> <pre><code>('apple', 'banana', 'peach')\n('apple', 'banana', 'peach', 'strawberry', 'pineapple')\n</code></pre> <p>Note</p> <p>Both the approaches shown above to manipulate tuple elements do not change the fact that tuples are immutable.</p> <p>In both cases, a new tuple is created every time that replaces the old one. The original tuple cannot be updated after its initial definition.</p> CodeOutput <pre><code>fruits = ('apple', 'banana', 'peach')\n\n# convert fruits tuple to a list\n# and store in new_fruits\nnew_fruits = list(fruits)\n\n# modify elements (e.g. add new element)\nnew_fruits.append('strawberry')\n\n# convert new_fruits list to tuple\nnew_fruits = tuple(new_fruits)\n\n# output new tuple\nprint('new:', new_fruits)\n\n# output original tuple\nprint('original:', fruits)\n</code></pre> <pre><code>('apple', 'banana', 'peach', 'strawberry')\n('apple', 'banana', 'peach')\n</code></pre> <p>As you can see, the original tuple remains as-is as <code>list(fruits)</code> returns a completely new list and doesn't change the original tuple.</p> <p>Similarly performing <code>tup1 + tup2</code> returns a new tuple with elements of both <code>tup1</code> and <code>tup2</code> but the content of <code>tup1</code> and <code>tup2</code> remains the same as original.</p> CodeOutput <pre><code>tup1 = ('a', 'b', 'c')\ntup2 = ('d', 'e', 'f')\ntup3 = tup1 + tup2\n\nprint(tup3)\nprint(tup1)\nprint(tup2)\n</code></pre> <pre><code>('a', 'b', 'c', 'd', 'e', 'f')\n('a', 'b', 'c')\n('d', 'e', 'f')\n</code></pre>"},{"location":"data-structures/tuples/unpacking-tuples/","title":"7.2.3. Unpacking Tuples","text":"<p>In Python, the values stored in a tuple can be assigned to different variables. While this can be done by simply indexing the tuple and assigning the values to variables, Python offers a more elegant and convenient syntax to achieve this.</p>"},{"location":"data-structures/tuples/unpacking-tuples/#unpacking-vs-indexing","title":"Unpacking vs Indexing","text":"<p>Lets say we have a tuple to store the name and age of an employee:</p> <pre><code>employee = ('John', 36)\n</code></pre> <p>What would be the ideal way of creating accessing the two values stored in this tuple and assigning them to <code>name</code> and <code>age</code> variables?</p> <p>If you don't know about unpacking, you most likely came up with this solution:</p> <pre><code>name = employee[0]\nage = employee[1]\n</code></pre> <p>Well, that's correct too but there's a better way of doing this: Unpacking.</p> <pre><code>name, age = employee\n</code></pre> <p>Now if we execute this code:</p> CodeOutput <pre><code>employee = ('John', 36)\nname, age = employee\n\nprint(name, age)\n</code></pre> <pre><code>John 36\n</code></pre> <p>As you can see, the variables are getting the appropriate value. If we compare the two approaches:</p> Without UnpackingWith Unpacking <pre><code>employee = ('John', 36)\nname = employee[0]\nage = employee[1]\n\nprint(name, age)\n</code></pre> <pre><code>employee = ('John', 36)\nname, age = employee\n\nprint(name, age)\n</code></pre> <p>Surely, unpacking makes things much easier. Now that we have established the basics of unpacking, let us understand this feature in more detail.</p>"},{"location":"data-structures/tuples/unpacking-tuples/#understanding-unpacking","title":"Understanding Unpacking","text":"<p>Unpacking is used to assign the values of a tuple to individual variables.</p> <p>In the example we saw before, we were assigning the values of the tuple <code>employee</code> to <code>name</code> and <code>age</code> variables. If we look at the syntax:</p> <pre><code>name, age = ('John', 18)\n</code></pre> <p>The first value of the tuple is assigned to first variable on left hand side and second value is assigned to second variable.</p> <p>Note that the number of variables on left hand side of this assignment expression should be same as number of items in the tuple.</p> <p>The workaround for this caveat is discussed below.</p>"},{"location":"data-structures/tuples/unpacking-tuples/#using-the-asterik-operator","title":"Using the <code>*</code> (asterik) operator","text":"<p>The <code>*</code> operator can be used as a workaround for the error discussed above which occurs when number of items to unpack and number of unpacked variables are not equal.</p> CodeOutput <pre><code>name, age, *roles = ('John', 23, 'Developer', 'Events Manager')\n\nprint(name)\nprint(age)\nprint(roles)\n</code></pre> <pre><code>John\n23\n['Developer', 'Events Manager']\n</code></pre> <p>As you can see, the first and second values were unpacked to <code>name</code> and <code>age</code> variables and since <code>roles</code> has preceeding <code>*</code> operator, the rest of the values are stored in <code>roles</code> as list.</p> <p><code>*</code> can be used in beginning too. This works by unpacking values from end of the tuple.</p> CodeOutput <pre><code>*a, b, c, d = ('first', 'second', 'third', 'fourth', 'fifth')\n\nprint(a)\nprint(b)\nprint(c)\nprint(d)\n</code></pre> <pre><code>['first', 'second']\nthird\nfourth\nfifth\n</code></pre> <p>The last three were unpacked to <code>b</code>, <code>c</code> and <code>d</code> variables and rest from the start were stored in list <code>a</code>.</p> <p>Similarly, the <code>*</code> in middle can be used to unpack values from start and end and the middle ones separated as list.</p> CodeOutput <pre><code>a, *b, c, d = ('first', 'second', 'third', 'fourth', 'fifth')\n\nprint(a)\nprint(b)\nprint(c)\nprint(d)\n</code></pre> <pre><code>first\n['second', 'third']\nfourth\nfifth\n</code></pre>"},{"location":"data-structures/tuples/unpacking-tuples/#unpacking-function-arguments","title":"Unpacking Function Arguments","text":"<p>Tuple values can also be unpacked and be passed to function arguments. This is also done using the <code>*</code> operator.</p> <p>Consider the following function that multiplies two numbers:</p> CodeOutput <pre><code>def product(a, b):\n    return a * b\n\nprint(product(2, 5))\n</code></pre> <pre><code>10\n</code></pre> <p>In this case, the output is <code>10</code>. If we have a tuple with same number of elements as arguments, we can pass it to function.</p> CodeOutput <pre><code>def product(a, b):\n    return a * b\n\nparams = (2, 5)\nprint(product(*params))\n</code></pre> <pre><code>10\n</code></pre> <p>Here, the first element of tuple, <code>2</code>, is assigned to first parameter, <code>a</code>, and second element, <code>5</code>, is assigned to second parameter, <code>b</code>.</p>"},{"location":"data-structures/tuples/unpacking-tuples/#unpacking-return-values","title":"Unpacking Return Values","text":"<p>We learned in section 5.3. Return Value that functions can return multiple values.</p> <p>These multiple return values are actually represented as tuples.</p> <p>For example, the following function divides the two numbers and returns the result of division as well as remainder:</p> CodeOutput <pre><code>def divide(n, m):\n    return n / m, n % m\n\nresult = divide(5, 2)\nprint(result)\n</code></pre> <pre><code>(2.5, 1)\n</code></pre> <p>Note</p> <p>Recall that <code>%</code> operator is used for calculating remainder as discussed in section 2.4. Mathematical Operations.</p> <p>As you can see in output, the function is returning a tuple. We can unpack this tuple like so:</p> CodeOutput <pre><code>def divide(n, m):\n    return n / m, n % m\n\nresult, remainder = divide(5, 2)\nprint(result)\nprint(remainder)\n</code></pre> <pre><code>2.5\n1\n</code></pre> <p>Unpacking with lists and other iterables</p> <p>While most commonly, tuples are used for unpacking. Other sequences like lists or iterables can be unpacked too.</p>"},{"location":"exception-handling/common-errors/","title":"6.4. Common Errors","text":"<p>Following is a list of some common errors that are encountered in Python.</p> <code>AttributeError</code> <p>This is raised when an attribute cannot be set or accessed on a class or object.</p> <p>Detail of this is covered in later sections.</p> <code>IndexError</code> <p>This is raised when a string or a sequence index is greater than the maximum allowed index.</p> <p>For example, if we have a string of five characters <code>'Hello'</code>, the maximum index is <code>4</code> (starting from <code>0</code>). If we index this string with an index larger than <code>4</code>, <code>IndexError</code> is raised.</p> <p>For more information, see section 4.1. Indexing Strings</p> <code>KeyError</code> <p>This is raised when a key does not exist in a dictionary. This is covered in detail in later sections.</p> <code>KeyboardInterrupt</code> <p>Raised when a program is terminated with the Ctrl+C key. This error shouldn't be handled.</p> <code>NameError</code> <p>Raised when a variable is used which was never defined.</p> <pre><code>print(a)\n</code></pre> <p>This code raises NameError since <code>a</code> is not defined.</p> <code>SyntaxError</code> <p>Raised when an invalid syntax is used. This error cannot be handled in most cases.</p> <code>IndentationError</code> <p>Raised when there is an indentation error.</p> <code>TabError</code> <p>Raised when there is inconsistent use of tabs and spaces in indentation.</p> <code>TypeError</code> <p>Raised when operation performed is on invalid type. This occurs in many cases with most common one being:</p> <ul> <li>Invalid parameters in functions (extra or missing argument)</li> <li>Mathematical operation between types that don't support mathematical   operations.</li> <li>Argument passed to a function is of invalid type.</li> </ul> <code>UnboundLocalError</code> <p>Raised when a variable is accessed before it is defined.</p> <p>Example:</p> <pre><code>print(a)\na = 20\n</code></pre> <code>ValueError</code> <p>Raised when a function gets a value of correct type but the value is improper. For example, passing non-convertible string to <code>int()</code> function.</p> <code>ZeroDivisionError</code> <p>Raised when division by zero is attempted.</p> <p>There are many other errors that are raised in various situations but all of them cannot be documented here. See Python Documentation for more information.</p>"},{"location":"exception-handling/else-finally-statements/","title":"6.2. <code>else</code> &amp; <code>finally</code> statements","text":"<p>Apart from <code>except</code>, we can also use <code>else</code> and a <code>finally</code> statement with a <code>try</code> block. These are covered in this section.</p>"},{"location":"exception-handling/else-finally-statements/#try-except-else","title":"<code>try</code>-<code>except</code>-<code>else</code>","text":"<p>An <code>else</code> block can be added after <code>except</code> block which would be executed when error does not occur.</p> CodeOutput #1Output #2 <pre><code>n1 = int(input('Enter number 1: '))\nn2 = int(input('Enter number 2: '))\n\ntry:\n    print(n1 / n2)\nexcept ZeroDivisionError:\n    print('number 2 cannot be zero!')\nelse:\n    print('division successful')\n</code></pre> <pre><code>Enter number 1: 8\nEnter number 2: 2\n4.0\ndivision successful\n</code></pre> <pre><code>Enter number 1: 8\nEnter number 2: 0\nnumber 2 cannot be zero!\n</code></pre> <p>This <code>else</code> is not executed when error is raised and <code>except</code> is executed.</p>"},{"location":"exception-handling/else-finally-statements/#try-except-finally","title":"<code>try</code>-<code>except</code>-<code>finally</code>","text":"<p>The <code>finally</code> block is used with <code>try</code> to execute the code after all the error handling is performed:</p> CodeOutput #1Output #2 <pre><code>n1 = int(input('Enter number 1: '))\nn2 = int(input('Enter number 2: '))\n\ntry:\n    print(n1 / n2)\nexcept ZeroDivisionError:\n    print('number 2 cannot be zero!')\nfinally:\n    print('program ended')\n</code></pre> <pre><code>Enter number 1: 8\nEnter number 2: 2\n4.0\nprogram ended\n</code></pre> <pre><code>Enter number 1: 8\nEnter number 2: 0\nnumber 2 cannot be zero!\nprogram ended\n</code></pre> <p>The <code>finally</code> block is always executed at the end once all other blocks are done executing.</p>"},{"location":"exception-handling/else-finally-statements/#try-finally","title":"<code>try-finally</code>","text":"<p><code>try</code> can be paired with <code>finally</code> without an <code>except</code>. In this case, the code in <code>try</code> block is executed and if an error occurs, <code>finally</code> block is executed before raising the error.</p> CodeOutput #1Output #2 <pre><code>n1 = int(input('Enter number 1: '))\nn2 = int(input('Enter number 2: '))\n\ntry:\n    print(n1 / n2)\nfinally:\n    print('program ended')\n</code></pre> <pre><code>Enter number 1: 8\nEnter number 2: 2\n4.0\nprogram ended\n</code></pre> <pre><code>Enter number 1: 8\nEnter number 2: 0\nnumber 2 cannot be zero!\nprogram ended\nTraceback (most recent call last):\n  File \"C:\\XGuides\\python\\test.py\", line 5, in &lt;module&gt;\n    print(n1 / n2)\n          ~~~^~~~\nZeroDivisionError: division by zero\n</code></pre>"},{"location":"exception-handling/else-finally-statements/#try-except-else-finally","title":"<code>try</code>-<code>except</code>-<code>else</code>-<code>finally</code>","text":"<p><code>finally</code> can also be applied with <code>try</code>-<code>except</code>-<code>else</code>.</p> <pre><code>try:\n    # do something here\n    ...\nexcept Exception:\n    # handle Exception here\n    ...\nelse:\n    # if no error occurs, do something here\n    ...\nfinally:\n    # regardless of error occurs or not, do this\n    # at the end\n    ...\n</code></pre> <p>Order of blocks</p> <p>Following rules should must be followed for order of try, except, else and finally blocks:</p> <ul> <li>The first block is always <code>try</code>.</li> <li><code>else</code> can only be added when <code>except</code> is used.</li> <li><code>else</code> is always put after all the <code>except</code> blocks.</li> <li><code>finally</code> is always the last block.</li> </ul> <p>In short, the only valid blocks order are:</p> <ul> <li><code>try</code>-<code>except</code></li> <li><code>try</code>-<code>except</code>-<code>else</code></li> <li><code>try</code>-<code>except</code>-<code>else</code>-<code>finally</code></li> <li><code>try</code>-<code>except</code>-<code>finally</code></li> <li><code>try</code>-<code>finally</code></li> </ul>"},{"location":"exception-handling/pass-statement/","title":"6.3. <code>pass</code> statement","text":"<p>The <code>pass</code> statement is used to do, well, nothing. Yes you heard that right, <code>pass</code> statement does nothing! You might say it's useless then but it has  various uses.</p>"},{"location":"exception-handling/pass-statement/#in-error-handling","title":"In error handling","text":"<p>In <code>except</code> or other blocks, <code>pass</code> is used to do nothing. Lets say, we've an error handling code that handles an error and simply ignores it, we can use <code>pass</code> there.</p> <pre><code>try:\n    # do something here\n    ...\nexcept Exception:\n    # do nothing if error occurs\n    pass\n</code></pre> <p>When Python sees a <code>pass</code>, it does nothing on that line and moves to the next line.</p>"},{"location":"exception-handling/pass-statement/#in-functions-codeblocks","title":"In functions &amp; codeblocks","text":"<p>In functions, <code>pass</code> is used as placeholder for missing code. Sometimes, you write a function definition and leave the body to be written for future.</p> <p><code>pass</code> acts as a placeholder to prevent an error from empty code since empty code is not allowed in codeblocks (if, else, loops, functions etc.)</p> Without passWith pass <pre><code># THIS CODE RAISES AN ERROR\n\ndef func():\n\nfunc()\n</code></pre> <pre><code># THIS CODE DOES NOT RAISE AN ERROR\n\ndef func():\n    pass\n\nfunc()\n</code></pre>"},{"location":"exception-handling/try-except-statements/","title":"6.1. <code>try</code> &amp; <code>except</code> statements","text":"<p>When working with complex programs, you often encounter errors or exceptions. In this section, we'll see how to handle these errors.</p>"},{"location":"exception-handling/try-except-statements/#error-vs-exception","title":"Error vs Exception","text":"<p>In some other programming languages, errors and exceptions are two different  things. In Python, both these terms generally mean the same thing but there is still some difference.</p> <p>Errors are issues that prevent a program from execution and cannot be handled. For example, a <code>SyntaxError</code> cannot be handled and is hence considered an \"error\".</p> <p>Exceptions are issues that interrupt the flow of program and can be handled. For example, <code>ZeroDivisionError</code> is an exception that occurs when division by 0 is attempted. This can be handled and is thus called an \"exception\".</p> <p>Note that, at least in Python's context, these two terms are generally used synonymously and often mean the same thing.</p>"},{"location":"exception-handling/try-except-statements/#tracebacks","title":"Tracebacks","text":"<p>When we encounter an exception, we see a long error message that we refer to as \"traceback\". See section 2.5. Dealing with Errors for more information.</p> CodeError <pre><code>n1 = int(input('Enter number 1: '))\nn2 = int(input('Enter number 2: '))\n\nprint(n1 / n2)  # (1)!\n</code></pre> <ol> <li>This line is causing the exception.</li> </ol> <pre><code>Enter number 1: 8\nEnter number 2: 0\nTraceback (most recent call last):\n  File \"G:\\thepyguide\\main.py\", line 4, in &lt;module&gt;\n      print(n1 / n2)\n            ~~~^~~~\nZeroDivisionError: division by zero\n</code></pre> <p>This traceback holds useful information about the error including:</p> <ul> <li>the file in which error occured (line 5)</li> <li>the line where error occured (line 5)</li> <li>the description of error (line 7)</li> <li>and most importantly, the class of error (<code>ZeroDivisionError</code>) (line 7)</li> </ul>"},{"location":"exception-handling/try-except-statements/#try-except","title":"<code>try</code>-<code>except</code>","text":"<p>We can handle these errors using the <code>try</code> and <code>except</code> statements.</p> CodeOutput <pre><code>n1 = int(input('Enter number 1: '))\nn2 = int(input('Enter number 2: '))\n\ntry:\n    print(n1 / n2)\nexcept ZeroDivisionError:\n    print('number 2 cannot be zero!')\n</code></pre> <pre><code>Enter number 1: 8\nEnter number 2: 0\nnumber 2 cannot be zero!\n</code></pre> <p>Now our program does not crash with an exception. Instead, when that exception occurs, it is handled and an appropriate message is shown.</p> <p>Let us look at the syntax now:</p> <ul> <li> <p>The code indented under <code>try</code> block is code that could raise the   error. It could be a single line or multiple lines.</p> </li> <li> <p>Line 6 uses the <code>except</code> statement followed by the class of error   that should be handled, in this case, <code>ZeroDivisionError</code>.</p> <ul> <li><code>ZeroDivisionError</code> is one of many errors</li> </ul> </li> <li> <p>The code indented under the <code>except</code> block is code to execute when   that error occurs.</p> </li> </ul>"},{"location":"exception-handling/try-except-statements/#multiple-except-statements","title":"Multiple <code>except</code> statements","text":"<p>We can handle multiple exceptions by adding more <code>except</code> statements.</p> <p>For example, <code>ValueError</code> is raised by <code>int</code> function when the provided value cannot be converted to integer.</p> CodeError <pre><code>x = 'hello'\ny = int(x)\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"G:\\thepyguide\\main.py\", line 2, in &lt;module&gt;\n      y = int(x)\n          ^^^^^^\nValueError: invalid literal for int() with base 10: 'hello'\n</code></pre> <p>To avoid this, we can handle the <code>ValueError</code> alongside <code>ZeroDivisionError</code>.</p> CodeOutput <pre><code>try:\n    n1 = int(input('Enter number 1: '))\n    n2 = int(input('Enter number 2: '))\n    print(n1 / n2)\nexcept ZeroDivisionError:\n    print('number 2 cannot be zero!')\nexcept ValueError:\n    print('please provide a valid integer.')\n</code></pre> <pre><code>Enter number 1: abc\nplease provide a valid integer.\n</code></pre> <p>Note that it is considered a better practice to handle these errors separately and keep the code in the <code>try</code> block minimal. Following is an alternative but equivalent approach:</p> CodeOutput <pre><code>try:\n    n1 = int(input('Enter number 1: '))\n    n2 = int(input('Enter number 2: '))\nexcept ValueError:\n    print('please provide a valid integer.')\n\ntry:\n    print(n1 / n2)\nexcept ZeroDivisionError:\n    print('number 2 cannot be zero!')\n</code></pre> <pre><code>Enter number 1: abc\nplease provide a valid integer.\n</code></pre>"},{"location":"exception-handling/try-except-statements/#single-except-many-exceptions","title":"Single <code>except</code>, many exceptions","text":"<p>A single <code>except</code> can be used to handle multiple exceptions. This is done by separating the exceptions to handle using a comma <code>,</code>.</p> CodeOutput #1Output #2 <pre><code>try:\n    n1 = int(input('Enter number 1: '))\n    n2 = int(input('Enter number 2: '))\n    print(n1 / n2)\nexcept (ZeroDivisionError, ValueError):\n    print('error occured!')\n</code></pre> <pre><code>Enter number 1: abc\nerror occured!\n</code></pre> <pre><code>Enter number 1: 8\nEnter number 2: 0\nerror occured!\n</code></pre> <p>However you'll notice that for both zero division, and conversion to integer error, we're getting the same error message. We can deal with this using the <code>as</code> keyword which is discussed in next heading.</p>"},{"location":"exception-handling/try-except-statements/#as-keyword","title":"<code>as</code> keyword","text":"<p>Sometimes the error raised holds some useful information which we want to  access. To do this, we have to store the error in a variable.</p> <p>This is when <code>as</code> comes in handy. The <code>as</code> keyword is used to assign the raised error to a variable.</p> <p>When we're using single except to handle multiple errors, we can use <code>as</code> and builtin <code>isinstance</code> function to differentiate between the handled errors.</p> CodeOutput #1Output #2 <pre><code>try:\n    n1 = int(input('Enter number 1: '))\n    n2 = int(input('Enter number 2: '))\n    print(n1 / n2)\nexcept (ZeroDivisionError, ValueError) as error:\n    if isinstance(error, ZeroDivisionError):\n        print('number 2 cannot be zero!')\n    elif isinstance(error, ValueError):\n        print('conversion to integer is not possible')\n</code></pre> <pre><code>Enter number 1: abc\nconversion to integer is not possible\n</code></pre> <pre><code>Enter number 1: 8\nEnter number 2: 0\nnumber 2 cannot be zero!\n</code></pre> <p>Note</p> <p><code>isinstance()</code> is a builtin function used for checking if something is an instance of a type. In this case, <code>ZeroDivisionError</code> and <code>ValueError</code> are two types and we're checking if <code>error</code> is an instance of those types.</p> <p>Here, <code>error</code> is an instance of the handled error, either <code>ZeroDivisionError</code> or <code>ValueError</code>.</p>"},{"location":"exception-handling/try-except-statements/#bare-except-statements","title":"Bare except statements","text":"<p>Until this point, we used explicit <code>except</code> statements in which we provided the list of exceptions that are to be handled.</p> <p>There are also \"bare\" except statements in which exceptions to be handled are not provided and it catches any exception raised.</p> <pre><code>n1 = int(input('Enter number 1: '))\nn2 = int(input('Enter number 2: '))\n\ntry:\n    print(n1 / n2)\nexcept:\n    print('number 2 cannot be zero!')\n</code></pre> <p>In this code, the <code>except</code> is bare as it does not provide any exceptions that must be handled. This except would catch any error, not necessarily <code>ZeroDivisionError</code>, that occurs in try block.</p>"},{"location":"exception-handling/try-except-statements/#drawback","title":"Drawback","text":"<p>Bare <code>except</code> statements are considered a bad practice. This is because bare except handles all kind of errors, even those that are not meant to be handled.</p> <p>Consider the following code: <pre><code>while True:\n    print('Hello')\n</code></pre></p> <p>When you run this program, it continously prints the message in console in an endless loop. If you want to terminate the program, you can press Ctrl+C which raises a <code>KeyboardInterrupt</code> exception and terminates the program.</p> <p>If we put this code into a <code>try</code>-<code>except</code> block with bare except block. The <code>KeyboardInterrupt</code> exception is handled by <code>except</code> and program doesn't terminate as desired.</p> <pre><code>try:\n    while True:\n        print('Hello')\nexcept:  # the wrong way\n    print('you cannot exit the program')\n</code></pre> <p>This is why, due to handling of unexpected and unwanted errors, bare excepts are not used in good code.</p>"},{"location":"exception-handling/try-except-statements/#alternative","title":"Alternative","text":"<p>An alternative to bare except is handling <code>Exception</code> exception. This exception is the base class for all \"should be handled\" exceptions.</p> <p>Exceptions like <code>KeyboardInterrupt</code> and <code>SystemExit</code> that should not be handled are not included in this class so they are not handled.</p> <pre><code>try:\n    while True:\n        print('Hello')\nexcept Exception:  # the right way\n    print('error occured but ignored')\n</code></pre> <p>Above except statement will catch all the appropriate exceptions.</p>"},{"location":"functions/arguments/","title":"5.2. Arguments","text":"<p>In section 5.1. Basics of Functions, we learned about functions. This section will cover function arguments.</p> <p>As discussed in previous section, a function could take one or more arguments. An argument is essentially an input to a function that it uses while processing to generate the output.</p> CodeOutput <pre><code>def greet():\n    print('From greet() function:')\n    print('Hello, World!')\n\ndef greet_with_name(name):\n    print('From greet_with_name() function:')\n    print(f'Hello, {name}!')\n\ngreet()\ngreet_with_name('John')\n</code></pre> <pre><code>From greet() function:\nHello, World!\nFrom greet_with_name() function:\nHello, John!\n</code></pre> <p>In above code, there are two functions. <code>greet</code> function does not take any arguments while <code>greet_with_name</code> takes one argument: <code>name</code>.</p> <p>Parameter vs Argument</p> <p>The terms \"parameter\" and \"argument\" are often used synonymously and have the same meaning in general but technically speaking:</p> <ul> <li>A parameter is the variable used when defining the function.</li> <li>An argument is the value/variable passed to the function while calling it.</li> </ul> <pre><code>def add(n1, n2):\n    return n1 + n2\n\nresult = add(5, 2)\nprint(result)\n</code></pre> <p>In this case, <code>n1</code> and <code>n2</code> on line 1 are parameters and <code>5</code> and <code>2</code> on line 4 are arguments. It is normal to use these terms interchangably.</p>"},{"location":"functions/arguments/#default-arguments","title":"Default Arguments","text":"<p>Normally, when we don't pass an argument when calling a function that expects arguments, we get an error:</p> CodeOutput <pre><code>def greet(name):\n    print(f'Hello, {name}!')\n\ngreet()\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"C:\\XGuides\\python\\test.py\", line 4, in &lt;module&gt;\n    greet()\nTypeError: greet() missing 1 required positional argument: 'name'\n</code></pre> <p>We can assign default values to arguments that are used when no value for that argument is passed upon calling it.</p> CodeOutput <pre><code>def greet(name='World'):\n    print(f'Hello, {name}!')\n\ngreet()\ngreet('John')\n</code></pre> <pre><code>Hello, World!\nHello, John!\n</code></pre> <p>In code shown, the first call doesn't provide any argument so it uses the default value. In second call, a value is passed which is used instead of default.</p> <p>Position of default arguments</p> <p>Default arguments should must be placed after required arguments in a function that has both default and required arguments.</p> <p>WRONG:</p> CodeError <pre><code>def func(optional='', required):\n    ...\n</code></pre> <pre><code>File \"C:\\XGuides\\python\\test.py\", line 1\n  def func(optional='', required):\n                        ^^^^^^^^\nSyntaxError: non-default argument follows default argument\n</code></pre> <p>CORRECT: <pre><code>def func(required, optional=''):\n    ...\n</code></pre></p> <p>This is only the case for positional arguments. Keyword arguments don't have this caveat.</p>"},{"location":"functions/arguments/#positional-keyword-arguments","title":"Positional &amp; Keyword Arguments","text":"<p>Consider the following code:</p> CodeOutput <pre><code>def greet(name, informal):\n    if informal:\n        print(f'Howdy, {name}!')\n    else:\n        print(f'Hello, {name}!')\n\ngreet('John', True)\n</code></pre> <pre><code>Howdy, John!\n</code></pre> <p>In this code, when calling the function, the parameters are passed in the same sequence as they are defined. These are called \"positional arguments\".</p> <p>On the other hand, the function could also be called like this:</p> CodeOutput <pre><code>greet('John', informal=True)\n</code></pre> <pre><code>Howdy, John!\n</code></pre> <p>In this case, <code>'John'</code> (the value for <code>name</code>) is the positional argument and <code>informal=True</code> is a \"keyword argument\".</p> <p>Alternatively, both arguments could be passed as keyword arguments:</p> CodeOutput <pre><code>greet(name='John', informal=True)\n</code></pre> <pre><code>Howdy, John!\n</code></pre> <ul> <li> <p>Keyword arguments are arguments that are passed by explicitly assigning the value to the   argument using its name.</p> </li> <li> <p>Positional arguments are arguments that are passed as per the sequence of arguments defined   in function header.</p> </li> </ul> <p>Warning</p> <p>Keyword arguments should be passed after positional arguments.</p>"},{"location":"functions/arguments/#variadic-arguments","title":"Variadic Arguments","text":"<p>Until now, we defined functions that either took no argument or a specific number of arguments. We can also define functions that can take variable amount of arguments.</p>"},{"location":"functions/arguments/#variadic-positional-arguments","title":"Variadic Positional Arguments","text":"CodeOutput <pre><code>def greet(*names):\n    for name in names:\n        print(f'Hello, {name}!')\n\ngreet('John', 'Peter', 'Alex')\n</code></pre> <pre><code>Hello, John!\nHello, Peter!\nHello, Alex!\n</code></pre> <p>In this code, <code>*names</code> in arguments list means that this argument can take variable amount of arguments. Inside the function, <code>names</code> is a tuple of values that were passed.</p> CodeOutput <pre><code>def greet(*names):\n    print(names[0])\n    print(names[1])\n    print(names[2])\n\ngreet('John', 'Peter', 'Alex', 'Marsh')\n</code></pre> <pre><code>John\nPeter\nAlex\n</code></pre>"},{"location":"functions/arguments/#variadic-keyword-arguments","title":"Variadic Keyword Arguments","text":"<p>We can also take variable keyword arguments by adding double <code>*</code> before the argument name.</p> CodeOutput <pre><code>def func(**args):\n    print(args['arg1'])\n    print(args['arg2'])\n\nfunc(arg1='hello', arg2='world', arg3='bye', arg4='world')\n</code></pre> <pre><code>hello\nworld\n</code></pre> <p>In function body, variadic keyword arguments are treated as a dictionary with key representing the name of argument and value representing the passed value.</p>"},{"location":"functions/arguments/#mixing-arguments","title":"Mixing Arguments","text":"<p>Positional and keyword arguments can also be mixed in same function.</p> CodeOutput <pre><code>def func(*args, **kwargs):\n    print(args[0])\n    print(args[1])\n    print(kwargs['arg1'])\n    print(kwargs['arg2'])\n\nfunc('hello', 'world', 'test', arg1='hello world', arg2='bye world')\n</code></pre> <pre><code>hello\nworld\nhello world\nbye world\n</code></pre> <p>Note that positional arguments are always put before keyword arguments otherwise an error is raised.</p> <p>If there is a function that takes variadic positional arguments and normal positional arguments as well, the normal arguments would have to be passed as keyword arguments.</p> CodeOutput <pre><code>def func(*args, normal_arg, normal_arg2):\n    print(normal_arg)\n    print(normal_arg2)\n\n# Normal arguments (non-variadic arguments) have to be passed\n# as keyword arguments.\nfunc('hello', 'world', 'test', normal_arg='hello world', normal_arg2='bye world')\n</code></pre> <pre><code>hello world\nbye world\n</code></pre>"},{"location":"functions/arguments/#positional-only-arguments","title":"Positional-only Arguments","text":"<p>Sometimes you want some arguments to only be passed as positional instead of keyword. You can do this by adding a <code>/</code> after the arguments that are to be passed as positional.</p> <pre><code>def func(pos_only, pos_only2, /, other, other2):\n    ...  # function body here\n</code></pre> <p>The arguments before <code>/</code> symbol cannot be passed as keyword arguments and the ones after <code>/</code> can be passed as keyword or positional.</p> <pre><code>func(1, 2, 3, 4)  # no error\nfunc(1, 2, 3, other2=4)  # no error\nfunc(pos_only=1, pos_only2=2, other=3, other2=4)  # ERROR\n</code></pre> <p>On third line, there is an error since first two arguments have to be positional.</p>"},{"location":"functions/arguments/#keyword-only-arguments","title":"Keyword-only Arguments","text":"<p>Similar to positional-only arguments, arguments can also be marked as keyword-only using <code>*</code> symbol. <pre><code>def func(arg1, arg2, *, kwarg1, kwarg2):\n    ...  # function body here\n</code></pre></p> <p>The arguments after <code>*</code> symbol cannot be passed as positional arguments and the ones before <code>*</code> can be passed as keyword or positional.</p> <pre><code>func(1, 2, kwarg1=3, kwarg2=4)  # no error\nfunc(arg1=1, arg2=2, kwarg1=2, kwarg2=3)  # no error\nfunc(1, 2, 3, kwarg2=4)  # ERROR\nfunc(1, 2, 3, 4)  # ERROR\n</code></pre> <ul> <li>On third call, <code>3</code> (value for <code>kwarg1</code>) must be passed as keyword argument.</li> <li>On fourth call, both <code>3</code> and <code>4</code> have to be passed as keyword arguments.</li> </ul> <p>Tip</p> <p>Positional-only and Keyword-only arguments can also be mixed in same function.</p> <pre><code>def func(arg1, arg2, /, arg3, arg4, *, arg5, arg6):\n    pass\n</code></pre> <ul> <li><code>arg1</code> and <code>arg2</code> are positional only.</li> <li><code>arg3</code> and <code>arg4</code> can either be passed as positional or keyword.</li> <li><code>arg5</code> and <code>arg6</code> are keyword only.</li> </ul>"},{"location":"functions/builtin-functions/","title":"5.5. Built-in Functions","text":"<p>Python comes shipped with some predefined useful functions that we can use throughout our code. We've already seen some built-in functions like <code>print()</code>, <code>input()</code> and <code>range()</code>. This section some of the other useful ones.</p> <code>abs()</code> <p>Returns the absolute value of a number.</p> <p>In a nutshell, this converts a negative value to positive. For example, <code>abs(-2.5)</code> returns <code>2.5</code>.</p> <code>divmod()</code> <p>Returns the quotient and remainder of a division operation.</p> CodeOutput <pre><code>q, r = divmod(5, 2)\nprint(q)\nprint(r)\n</code></pre> <pre><code>2.5\n1\n</code></pre> <code>round()</code> <p>Rounds a number.</p> <p>For example, <code>round(5.2)</code> returns 5 and <code>round(5.6)</code> returns 6.</p> <p>This also takes a second parameter representing the decimals to round to. For example, <code>round(5.2793, 2)</code> returns <code>5.23</code>.</p> <code>len()</code> <p>Returns the length of a string or a sequence.</p> <p>For example, <code>len('hello john')</code> returns 10.</p> <code>ascii()</code> <p>Returns the ASCII code for a character.</p> <p>For example, <code>ascii('B')</code> returns 66.</p> <code>chr()</code> <p>Returns the character that maps to given ASCII code.</p> <p>For example, <code>chr(66)</code> returns <code>'B'</code>.</p> <p>There are many other builtin functions that can be used in many tasks but all of them cannot be listed here. See Python documentation for all functions.</p>"},{"location":"functions/functions-basics/","title":"5.1. Basics of Functions","text":"<p>Functions are named codeblocks that are only executed when called and perform a specific task.</p>"},{"location":"functions/functions-basics/#syntax","title":"Syntax","text":"<p>Functions are defined using the <code>def</code> keyword followed by name of function and any arguments or parameters the function takes. The body of function is indented inside <code>def</code>.</p> <p>For example, the following function calculates and returns the sum of two numbers: <pre><code>def add(n1, n2):\n    return n1 + n2\n</code></pre></p> <p>Inspecting above code:</p> <ul> <li><code>add</code> is the name of function.</li> <li><code>n1</code> and <code>n2</code> are known as parameters or arguments.</li> </ul>"},{"location":"functions/functions-basics/#calling-a-function","title":"Calling a function","text":"<p>If you define a function in your program and simply run the program, you won't get any output. This is because functions have to be called in order to be used.</p> CodeOutput <pre><code>def add(n1, n2):\n    return n1 + n2\n\nresult = add(5, 2)\nprint(result)\n</code></pre> <pre><code>7\n</code></pre> <p>Here,</p> <ul> <li>The function is called on line 4.</li> <li>While calling, the value of <code>n1</code> parameter is set to <code>5</code> and <code>n2</code> set is to <code>2</code>.</li> <li>The function's body is executed and the value <code>7</code> is returned (as a result of line 2)   which is then assigned to <code>result</code> variable.</li> </ul>"},{"location":"functions/functions-basics/#arguments","title":"Arguments","text":"<p>A function can take one or more parameters or arguments. An argument is essentially an input to a function that it uses while processing to generate the output.</p> CodeOutput <pre><code>def greet():\n    print('From greet() function:')\n    print('Hello, World!')\n\ndef greet_with_name(name):\n    print('From greet_with_name() function:')\n    print(f'Hello, {name}!')\n\ngreet()\ngreet_with_name('John')\n</code></pre> <pre><code>From greet() function:\nHello, World!\nFrom greet_with_name() function:\nHello, John!\n</code></pre> <p>In above code, there are two functions. <code>greet</code> function does not take any arguments while <code>greet_with_name</code> takes one argument: <code>name</code>.</p> <p>More on arguments is covered in section 5.2. Arguments.</p>"},{"location":"functions/functions-basics/#application","title":"Application","text":"<p>Here is an example of a comparatively complex function that calculates the factorial of a number:</p> CodeOutput <pre><code>def factorial(n):\n    fact = 1\n\n    for i in range(1, n + 1):\n        fact = n * i\n\n    return fact\n\nprint(factorial(3))\nprint(factorial(5))\nprint(factorial(6))\n</code></pre> <pre><code>6\n120\n720\n</code></pre> <p>Note</p> <p>Factorial of a number is the product of that number with the numbers below it down to 1. For example, the factorial of 3 is <code>3 * 2 * 1</code> and factorial of 5 is <code>5 * 4 * 3 * 2 * 1</code>.</p> <p>Note that factorial of 1 and 0 is 1, and negative and fractional numbers don't have any factorial.</p> <p>In this code, line 1-7 are defining the function and line 9-11 are calling the function three times.</p> <p>Note how the function is reused by calling it multiple times which is an application of function. We don't have to rewrite the factorial logic again when using it, we simply define the logic once as a function and call it whenever we want using the function name.</p> <p>Another benefit of functions apart from reusability is organizing a large program in smaller functions with each function performing a specific task. This way, it is easier to read, test and debug.</p>"},{"location":"functions/lambda-expressions/","title":"5.6. Lambda Expressions","text":"<p>Lambda expressions are small anonymous functions that can be defined in a single line. They are called anonymous because they don't have a name on their own.</p>"},{"location":"functions/lambda-expressions/#syntax","title":"Syntax","text":"<p>Anonymous functions are defined using the <code>lambda</code> keyword followed by list of parameters (if  any) and the expression inside the function.</p> CodeOutput <pre><code>adder = lambda a, b: a + b\nprint(adder(5, 2))\n</code></pre> <pre><code>7\n</code></pre> <p>Here, <code>adder</code> is an anonymous function that adds two integers. If we look at the syntax:</p> <ul> <li>The arguments function takes are defined before colon <code>:</code> and after <code>lambda</code> keyword</li> <li>The expression that the function returns is written after colon <code>:</code></li> </ul> <p>Lambda can only contain one expression after the <code>:</code> but supports all features of parameters shown in section 5.2. Arguments including default value, variadic arguments and positional/keyword-only arguments.</p>"},{"location":"functions/lambda-expressions/#application","title":"Application","text":"<p>Lambda functions are generally used when there is a need of a small function temporarily in some code.</p> <p>Another use of these functions are in closures that are defined using nested functions.</p> <p>For example:</p> CodeOutput <pre><code>def factor(a):\n    return lambda b: b * a\n\ndoubler = factor(2)\ntripler = factor(3)\n\nprint(doubler(20))\nprint(tripler(20))\n</code></pre> <pre><code>40\n60\n</code></pre>"},{"location":"functions/return-value/","title":"5.3. Return Value","text":"<p>Functions could return a value as a result of its calling. This page covers various features and details about the <code>return</code> statement.</p> <p>We've already seen in previous sections how return works. It returns a value back to the caller.</p> CodeOutput <pre><code>def add(n1, n2):\n    return n1 + n2\n\nresult = add(5, 2)\nprint(result)\n</code></pre> <pre><code>7\n</code></pre> <p>Here, <code>result</code> is assigned the value returned by function.</p>"},{"location":"functions/return-value/#behaviour-of-return","title":"Behaviour of <code>return</code>","text":"<p>The <code>return</code> statement is like a terminating statement for a function. When you return something, the function terminates with the returned value.</p> CodeOutput <pre><code>def check_password(password):\n    if password == '1234':\n        return True\n\n    return False\n\nprint(check_password('1234'))\nprint(check_password('123456'))\n</code></pre> <pre><code>True\nFalse\n</code></pre> <p>In this case, when we passed <code>1234</code> to <code>password</code> parameter, the if condition was satisfied and <code>return True</code> on line 3 was executed. As soon as this happened, the rest of the function body was skipped and <code>True</code> was yielded back to caller.</p> <p>On the otherhand, when if condition wasn't satisfied (second function call), the rest of function body was executed and <code>False</code> was returned.</p> <p>This is equivalent to the following code but the <code>else</code> block is unnecessary here:</p> CodeOutput <pre><code># equivalent to code shown above\ndef check_password(password):\n    if password == '1234':\n        return True\n    else:\n        # This else block is redundant and unnecessary!\n        return False\n\nprint(check_password('1234'))\nprint(check_password('123456'))\n</code></pre> <pre><code>True\nFalse\n</code></pre>"},{"location":"functions/return-value/#return-nothing","title":"Return nothing","text":"<p>In some cases, a function performs an action and returns nothing. \"Nothing\" in Python is represented using the <code>None</code> value.</p> CodeOutput <pre><code>def greet(name):\n    print(f'Hello, {name}!')\n\nresult = greet('John')\nprint(result)\n</code></pre> <pre><code>Hello, John!\nNone\n</code></pre> <p>Since <code>greet()</code> has no <code>return</code> statement and isn't returning anything, it simply returns a <code>None</code> value representing nothing was returned.</p>"},{"location":"functions/return-value/#return-vs-print","title":"Return vs Print","text":"<p>Do not confuse \"returning a value\" and \"printing a value\". In cases shown previously, both might seem to do the same thing but there's a difference.</p> <p><code>print()</code> itself is a builtin function that simply outputs the given message to console.</p> <p><code>return</code> on the other hand, is a keyword used in a function to yield the value back to caller.</p> <p>When we do, <code>print(2)</code>, we're telling Python to show the output on screen. In case of <code>return 2</code> inside a function, we're telling Python to assign the value <code>2</code> to the call of the given function.</p> CodeOutput <pre><code>def print_value():\n    print(12)\n\ndef return_value():\n    return 12\n\nprint_value()  # prints 12\nreturn_value()  # does nothing\n</code></pre> <pre><code>12\n</code></pre> <p>However, to print result of <code>return_value</code>, we use the print again:</p> CodeOutput <pre><code>print_value()  # prints 12\nprint(return_value())  # prints returned value of return_value()\n</code></pre> <pre><code>12\n12\n</code></pre>"},{"location":"functions/return-value/#returning-multiple-values","title":"Returning multiple values","text":"<p>A function could return a sequence of values. To do so, separate the values to return using a comma <code>,</code>.</p> <p>For example, consider this function that returns result of division and remainder:</p> CodeOutput <pre><code>def divide_and_remainder(n1, n2):\n    return n1 / n2, n1 % n2\n\nvalues = divide_and_remainder(5, 2)\nprint(values[0])\nprint(values[1])\n</code></pre> <pre><code>2.5\n1\n</code></pre> <p>In fact, the values returned are stored as a tupleand could be unpacked too:</p> CodeOutput <pre><code>quotient, remainder = divide_and_remainder(5, 2)\nprint(quotient)\nprint(remainder)\n</code></pre> <pre><code>2.5\n1\n</code></pre> <p>Note</p> <p>Function shown in above example is same as builtin <code>divmod()</code> function.</p>"},{"location":"functions/return-value/#returning-nested-functions","title":"Returning Nested Functions","text":"<p>Nested functions are also referred to as closures and are used to retain values from original (outer) function even after the original function is done executing.</p> CodeOutput <pre><code>def factor(a):\n    def inner(b):\n        return a * b\n\n    return inner\n\ndoubler = factor(2)\ntripler = factor(3)\n\nprint(doubler(20))\nprint(tripler(20))\n</code></pre> <pre><code>40\n60\n</code></pre> <p>In this case, we're creating a function inside <code>factor</code> everytime it is called and returning it.</p>"},{"location":"functions/scopes/","title":"5.4. Scopes","text":"<p>Scopes in Python determines the places in your code where a specific variable or function is valid or can be accessed.</p> <p>Note</p> <p>In this article, the term \"name\" is used to generally refer to anything a scope holds such as a variable or function.</p>"},{"location":"functions/scopes/#global-scope","title":"Global Scope","text":"<p>Global scope, also known as module scope, holds the names that are accessible throughout the program.</p> CodeOutput <pre><code>var = 42\n\ndef show_var():\n    print('accessing var from inside function:', var)\n\nprint('accessing var from outside function:', var)\nshow_var()\n</code></pre> <pre><code>accessing var from outside function: 42\naccessing var from inside function: 42\n</code></pre> <p>Here, <code>var</code> is a variable defined in global scope, hence called \"global variable\".</p> <p>Note that <code>show_var</code> function is also a global function. Another function could call <code>show_var</code> function in its body without a problem since it is defined globally.</p>"},{"location":"functions/scopes/#global-statement","title":"<code>global</code> statement","text":"<p>You cannot update a variable defined in global scope from inside a function.</p> CodeOutput <pre><code>var = 42\n\ndef update_var():\n    var = var + 1\n\nupdate_var()\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"C:\\XGuides\\python\\test.py\", line 6, in &lt;module&gt;\n    update_var()\n  File \"C:\\XGuides\\python\\test.py\", line 4, in update_var\n    var = var + 1\n        ^^^\nUnboundLocalError: cannot access local variable 'var' where it is not associated with a value\n</code></pre> <p>To do so, we use the <code>global</code> statement.</p> CodeOutput <pre><code>var = 42\n\ndef update_var():\n    global var\n    var = var + 1\n\nupdate_var()\nprint(var)  # 43\nupdate_var()\nprint(var)  # 44\n</code></pre> <pre><code>43\n44\n</code></pre> <p>When a variable is declared as <code>global</code>, its value can be manipulated globally from inside a function or another scope.</p> <p>Warning</p> <p>Using <code>global</code> is considered a bad practice because it tends to lead to problems in the long run. If you're using <code>global</code> in your code, look for alternative solutions as there's always a better approach to the problem.</p> <p>For example, one approach to write above code without global could be:</p> <pre><code>var = 42\n\ndef update_var():\n    var = var + 1\n\nvar = update_var()\nprint(var)  # 43\nvar = update_var()\nprint(var)  # 44\n</code></pre>"},{"location":"functions/scopes/#local-scope","title":"Local Scope","text":"<p>Local scope is a scope created by a function. It holds names that are only valid inside the function that the scope belongs to.</p> <p>Names inside local scopes are only valid inside the function and cannot be used outside it:</p> CodeOutput <pre><code>def func():\n    var = 42\n    print('inside function:', var)\n\nfunc()\nprint('outside function:', var)  # raises an error\n</code></pre> <pre><code>inside function: 42\nTraceback (most recent call last):\n  File \"C:\\XGuides\\python\\test.py\", line 6, in &lt;module&gt;\n    print('outside function:', var)  # raises an error\n                               ^^^\nNameError: name 'var' is not defined.\n</code></pre> <p><code>var</code> is created in function's local scope when function is called and when function is done executing, that scope is removed along with all the variables defined in it.</p> <p>Note that arguments of a function are also part of local scope and can only be accessed and manipulated within that function.</p>"},{"location":"functions/scopes/#enclosing-scope","title":"Enclosing Scope","text":"<p>Enclosing scope comes into play when we have nested functions (function defined inside another function).</p> <p>Consider the following example: <pre><code>def outer():\n    var = 42\n\n    def inner():\n        print(var)\n</code></pre></p> <p>In this case, the enclosing scope of <code>inner</code> is local scope of <code>outer</code>.</p>"},{"location":"functions/scopes/#nonlocal-statement","title":"<code>nonlocal</code> statement","text":"<p>Names defined in enclosing scope such as <code>var</code> can be accessed by inner function but cannot be updated.</p> CodeOutput <pre><code>def outer():\n    var = 42\n\n    def inner():\n        var = var + 1\n\n    inner()\n\nouter()\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"C:\\XGuides\\python\\test.py\", line 9, in &lt;module&gt;\n    outer()\n  File \"C:\\XGuides\\python\\test.py\", line 7, in outer\n    inner()\n  File \"C:\\XGuides\\python\\test.py\", line 5, in inner\n    var = var + 1\n          ^^^\nUnboundLocalError: cannot access local variable 'var' where it is not associated with a value\n</code></pre> <p>To do this, we use the <code>nonlocal</code> statement.</p> CodeOutput <pre><code>def outer():\n    var = 42\n\n    def inner():\n        nonlocal var\n        var = var + 1\n\n    print('before inner called:', var)\n    inner()\n    print('after inner called:', var)\n\nouter()\n</code></pre> <pre><code>before inner called: 42\nafter inner called: 43\n</code></pre>"},{"location":"fundamentals/comments/","title":"2.3. Comments","text":"<p>When writing a complex program, your code will surely get complicated at some point. A code is read much more often than it is written. Hence it is important that you ensure that others can understand your code.</p> <p>This is when comments are helpful. As the name suggests, comments are simply line of codes which solely exist to explain your code. These lines are ignored at execution time. In order to write a comment, start a line by a <code>#</code> symbol.</p> <p>For example,</p> <pre><code># This is a comment\nprint('This is a normal line of code')\n</code></pre> <p>In this code, the first line is a comment which will be ignored during execution.</p>"},{"location":"fundamentals/comments/#uses-of-comments","title":"Uses of Comments","text":"<ul> <li> <p>Explaining Code: Comments are used to include useful information in code which will help  others reading your code. It is a good practice to add comments when you think your code  could be too complicated to comprehend by a human.</p> </li> <li> <p>Debugging &amp; Testing: When working with programs, especially investigating errors or bugs in  code, it is a common practice to use comments to temporarily prevent a piece of code to execute by  commenting out that bit of code.</p> </li> <li> <p>Code Analysis &amp; Type Checking: For some third party tools that perform analysis on code or read the code, comments are used to manipulate their behaviour.</p> </li> </ul> <p>As you'll notice in next articles, we'll use comments throughout this guide for explaining the code snippets included in articles and we hope you do to in your code.</p>"},{"location":"fundamentals/dealing-with-errors/","title":"2.5. Dealing with Errors","text":"<p>Sometimes your code doesn't behave the way it should. This section will guide you through the process of dealing with errors so you know what to do when things go wrong.</p>"},{"location":"fundamentals/dealing-with-errors/#introduction-to-errors","title":"Introduction to Errors","text":"<p>An error occurs when your code does something which isn't allowed or isn't possible. Mainly there are two types of errors:</p> <ul> <li>Syntax Error</li> <li>Runtime Error</li> </ul> <p>Syntax Error occurs when you break the rules of a language grammar. Just like English has grammar, programming languages have some rules too. If you break these rules, you get a syntax error. In other words, this error occurs when you write something that computer cannot understand.</p> <p>Generally, syntax errors are easier to find. Due to this, the Python interpreter can detect these errors at the start of program and can alert you before program even executes.</p> <p>An example of syntax error:</p> CodeOutput <pre><code>print('Hello world)\n</code></pre> <p>In this code snippet, we are missing a closing quotation.</p> <pre><code>  File \"G:\\thepyguide\\main.py\", line 1\n    print('Hello world)\n          ^\nSyntaxError: unterminated string literal (detected at line 1)\n</code></pre> <p>Runtime Error relate more to unexpected behaviour at execution time. This error isn't detected before execution. This is why we often refer to them with a popular term: \"bugs\".</p> <p>For example, if we have a program that takes user input and divides two numbers, a runtime error can occur when user provides 0 for denominator:</p> CodeOutput <pre><code>n1 = int(input('Enter number 1: '))\nn2 = int(input('Enter number 2: '))\n\nprint(n1 / n2)\n</code></pre> <pre><code>Enter number 1: 8\nEnter number 2: 0\nTraceback (most recent call last):\n  File \"G:\\thepyguide\\main.py\", line 4, in &lt;module&gt;\n      print(n1 / n2)\n            ~~~^~~~\nZeroDivisionError: division by zero\n</code></pre>"},{"location":"fundamentals/dealing-with-errors/#understanding-errors","title":"Understanding errors","text":"<p>We understand how much the word \"error\" sounds scary but if you can understand the long error messages. You can tackle any error.</p> <p>When an error occurs, Python generates an error message known as \"error traceback\". This traceback message tells exactly where the error is coming from.</p> <p>For example in above error, if you look closely, the error traceback tells us following bits of useful information:</p> <ul> <li>The name and path of file in which error occured (test.py)</li> <li>The exact line where it occured (line 4)</li> <li>The error message describing what happened (division by zero)</li> </ul> ErrorCode <pre><code>Enter number 1: 8\nEnter number 2: 0\nTraceback (most recent call last):\n  File \"G:\\thepyguide\\main.py\", line 4, in &lt;module&gt;\n      print(n1 / n2)\n            ~~~^~~~\nZeroDivisionError: division by zero\n</code></pre> <ul> <li>Line 4 tells us the file name and line number that caused the error.</li> <li>Line 5 and 6 shows us the bit of code that caused the error.</li> <li>Line 7 shows the name of error, <code>ZeroDivisionError</code>, and an error message   describing the cause of error.</li> </ul> <pre><code>n1 = int(input('Enter number 1: '))\nn2 = int(input('Enter number 2: '))\n\nprint(n1 / n2)  # (1)!\n</code></pre> <ol> <li>This is where the error occured.</li> </ol> <p>Tip</p> <p>The rule of thumb is to always read the error messages. Sometimes the error message might not make sense to you; In that case, remember, Google is your friend.</p>"},{"location":"fundamentals/io-operations/","title":"2.2. I/O Operations","text":"<p>In this section, we'll be looking at how we can take input from user and produce an output.</p>"},{"location":"fundamentals/io-operations/#formatting-output","title":"Formatting output","text":"<p>For a recap, in the 1.3. Hello World, we learnt about the <code>print()</code> function which allows us to output messages.</p> <p>The <code>print()</code> function provides some extra functionality that allows us to format our output.</p>"},{"location":"fundamentals/io-operations/#multiple-messages","title":"Multiple messages","text":"<p>We can pass multiple messages to this function that will be separated by space when outputing:</p> CodeOutput <pre><code>print('Hello', 'World!')\n</code></pre> <pre><code>Hello World!\n</code></pre> <p>This is particulary useful when outputting values of a variable:</p> CodeOutput <pre><code>age = 20\nprint('The age of this user is', age, 'years.')\n</code></pre> <pre><code>The age of this user is 20 years.\n</code></pre> <p>By default, the passed messages are joined with space as a separator. If you want to change the separator, we can do that by passing a <code>sep</code> parameter:</p> CodeOutput <pre><code>print('apple', 'banana', 'peach', sep=', ')\n</code></pre> <pre><code>apple, banana, peach\n</code></pre>"},{"location":"fundamentals/io-operations/#newlines-and-ending","title":"Newlines and ending","text":"<p>In order to move to a newline when outputing messages, a special \"escape character\" is used.  This escape character is <code>\\n</code>.</p> <p>Escape Characters</p> <p>Other than new line escape characters, there are various other escape characters for various purposes which will be discussed later in this guide.</p> <p>For example:</p> CodeOutput <pre><code>print('Line 1\\nLine2\\nLine3')\n</code></pre> <pre><code>Line 1\nLine 2\nLine 3\n</code></pre> <p>Note that when we call a print statement. The output message automatically appended with a new line character. Hence, the following code produces the same output as above:</p> CodeOutput <pre><code>print('Line 1')\nprint('Line 2')\nprint('Line 3')\n</code></pre> <pre><code>Line 1\nLine 2\nLine 3\n</code></pre> <p>If we don't want the end of each output to be new line, we can pass another character to <code>end</code> argument. By default, <code>end</code> is set to <code>\\n</code></p> CodeOutput <pre><code>print('Line 1', end='.')\nprint('Line 2', end='.')\nprint('Line 3', end='.')\n</code></pre> <pre><code>Line 1.Line 2.Line 3.\n</code></pre>"},{"location":"fundamentals/io-operations/#taking-user-input","title":"Taking user input","text":"<p>A program is incomplete without user input. Every program requires an input in some way or another.</p> <p>The most basic way of taking user input is by using the <code>input()</code> function:</p> CodeOutput <pre><code>name = input('Enter your name: ') # (1)!\nprint('Hello,', name)\n</code></pre> <ol> <li>If we don't pass any message to <code>input()</code> function, no prompt is shown    in the terminal.</li> </ol> <pre><code>Enter your name: John # (1)!\nHello, John\n</code></pre> <ol> <li>\"John\" is the given user input.</li> </ol>"},{"location":"fundamentals/io-operations/#converting-input-type","title":"Converting input type","text":"<p>The <code>input()</code> function returns the input as a string (<code>str</code> data type). In cases where you are expecting a different type, you must convert the string to that type explicitly.</p> <p>For example, the following program takes two numbers and adds them:</p> CodeOutput <pre><code>n1 = input('Enter number 1: ')\nn2 = input('Enter number 2: ')\n\nn1 = int(n1)  # (1)!\nn2 = int(n2)  # (2)!\n\nprint(n1 + n2)\n</code></pre> <ol> <li>n1 converted to <code>int</code> type.</li> <li>n2 converted to <code>int</code> type.</li> </ol> <pre><code>Enter number 1: 20\nEnter number 2: 50\n70\n</code></pre> <p>For more information on data type conversion, take a look at the 2.1. Variables and Data Types: Converting data types topic.</p>"},{"location":"fundamentals/mathematical-operations/","title":"2.4. Mathematical Operations","text":"<p>In programming, we do a lot of computation. This computation more often than not involves mathematical calculations. In this section, we'll see some mathematical operations we can perform in Python.</p>"},{"location":"fundamentals/mathematical-operations/#basic-arithmetic","title":"Basic Arithmetic","text":"<p>Following are the operators for basic arithmetic operations:</p> <ul> <li><code>+</code> (Addition)</li> <li><code>-</code> (Subtraction)</li> <li><code>*</code> (Multiplication)</li> <li><code>/</code> (Division)</li> </ul> <p>For example:</p> CodeOutput <pre><code>n1 = 8\nn2 = 4\n\n# 8 + 4\nprint('Sum:', n1 + n2)\n\n# 8 - 2\nprint('Difference:', n1 - n2)\n\n# 8 \u00d7 2\nprint('Product:', n1 * n2)\n\n# 8 \u00f7 2\nprint('Division:', n1 / n2)\n</code></pre> <pre><code>Sum: 12\nDifference: 4\nProduct: 32\nDivision: 2.0\n</code></pre>"},{"location":"fundamentals/mathematical-operations/#other-operations","title":"Other Operations","text":"<p>Other operations that are also used often are:</p> <ul> <li><code>**</code> (Power)</li> <li><code>//</code> (Integer division)</li> <li><code>%</code> (Modulus i.e remainder of division)</li> </ul> CodeOutput <pre><code>n1 = 5\nn2 = 2\n\n# 5 raised to power 2\nprint('Power:', n1 ** n2)\n\n# Integer division (//) returns the integer part of\n# division result. For example, 5 / 2 results in 2.5\n# but 5 // 2 returns 2.\nprint('Division:', n1 // n2)\n\n# Modulus (%) returns remainder of division \nprint('Remainder:', n1 % n2)\n</code></pre> <pre><code>Power: 25\nDivision: 2\nRemainder: 1\n</code></pre> <p>Pitfall Alert</p> <p>Mathematical operations can only be performed between two values of <code>int</code> or <code>float</code> types. If you have a numeric string, you must convert it to proper data type first otherwise an error will occur.</p> <pre><code>n1 = '20'\nn2 = '30'\nprint(n1 * n2)  # Error!\n</code></pre>"},{"location":"fundamentals/variables-and-data-types/","title":"2.1. Variables and Data Types","text":"<p>In this section, we're going to look at one of the most fundamental concept of programming, variables and data types.</p>"},{"location":"fundamentals/variables-and-data-types/#introduction-to-variables","title":"Introduction to Variables","text":"<p>Simply put, variables are containers that store a specific value. Each variable has a name and a value. We can store any value to variable and when we want to access that value again, we can simply reference that variable with its name.</p> <p>For example, if we want to store the age of user, we can simply write: <pre><code>age = 20\n</code></pre> This is the syntax of creating variables. Here, left hand side of the <code>=</code> symbol represents the name of variable while the right hand side is the value assigned to variable.</p> <p>Note</p> <p><code>20 = age</code> is not a valid syntax. Left side is always the variable name with right side being the value to store.</p> <p>When we need the information, we can simply access it by referencing variable name:</p> CodeOutput <pre><code>age = 20\nprint(age)\n</code></pre> <pre><code>20\n</code></pre> <p>Variable types</p> <p>If you are coming from another language, you might be used to mentioning the type of variable when declaring it. In Python, the type is inferred automatically.</p>"},{"location":"fundamentals/variables-and-data-types/#rules-for-variable-name","title":"Rules for variable name","text":"<p>There are a few rules for the name of a variable which must be followed:</p> <ul> <li>Variable name can only contain letters, numbers or underscore.</li> <li>Variable name must start with a letter or underscore.</li> <li>Variable names are case-sensitive. (e.g. <code>age</code> and <code>Age</code> are two different variables)</li> </ul>"},{"location":"fundamentals/variables-and-data-types/#updating-a-variable","title":"Updating a variable","text":"<p>As the name suggest, variables value can be varied too. For example, in below snippet of code we are first assigning the value 20 to age and after printing that, we're updating the age variable to hold the value 30.</p> CodeOutput <pre><code>age = 20\nprint(age)\n\nage = 30\nprint(age)\n</code></pre> <pre><code>20\n30\n</code></pre> <p>When updating a variable, you can use the previous value too. For example, incrementing the previous age by one:</p> CodeOutput <pre><code>age = 20\nprint(age)\n\nage = age + 1\nprint(age)\n</code></pre> <pre><code>20\n21\n</code></pre>"},{"location":"fundamentals/variables-and-data-types/#data-types","title":"Data Types","text":"<p>In programming, we tend to deal with different kinds of data e.g. numbers, text, decimal numbers, dates etc.</p> <p>To categorize the data, we have data types in programming. Data types are used to represent the type or kind of data. In Python, we have four basic data types:</p> <ul> <li><code>str</code> (string) for textual data</li> <li><code>int</code> for integers or whole numbers</li> <li><code>float</code> for floating point (decimal) numbers</li> <li><code>bool</code> (boolean) for boolean values (<code>True</code> or <code>False</code>)</li> </ul>"},{"location":"fundamentals/variables-and-data-types/#strings","title":"Strings","text":"<p>The string type, <code>str</code>, is used to represent arbitrary textual values. In order to represent a string, we enclose the given text in quotes.</p> CodeOutput <pre><code>name = \"Harry Potter\"\nprint(name)\nprint(type(name))\n</code></pre> <pre><code>Harry Potter\n&lt;class 'str'&gt;\n</code></pre> <p>type() function</p> <p>When we call the <code>type(X)</code> function, it returns the type of <code>X</code>.</p> <p>Strings are used when we want to represent any textual value. It is important that we enclose strings in quotes, either double quotes or single quotes.</p> <pre><code>name = \"Harry Potter\"\nname2 = 'Harry Potter'\n</code></pre> <p>In this case, both <code>name</code> and <code>name2</code> are same. Worth noting that we cannot mix double and single quotes. If you start a string with double quote, you must end it with a double quote too and vice versa.</p> <p>This code will raise an error because quotes are not consistent: <pre><code>name = \"Harry Potter'\n</code></pre></p>"},{"location":"fundamentals/variables-and-data-types/#integers","title":"Integers","text":"<p>When we want to represent integers i.e whole numbers, we use the <code>int</code> data type. To represent numbers, we simply write the number as is. There is no need of enclosing them in quotes.</p> CodeOutput <pre><code>age = 20\nprint(age)\nprint(type(age))\n</code></pre> <pre><code>20\n&lt;class 'int'&gt;\n</code></pre> <p>A common pitfall is to enclose the number in quotes which makes it of <code>str</code> data type instead of <code>int</code> data type.</p>"},{"location":"fundamentals/variables-and-data-types/#floating-point-numbers","title":"Floating-point numbers","text":"<p>Floating-point numbers are simply decimal numbers. In Python, the data type to represent these numbers is called <code>float</code>.</p> CodeOutput <pre><code>pi = 3.14\nprint(pi)\nprint(type(pi))\n</code></pre> <pre><code>3.14\n&lt;class 'float'&gt;\n</code></pre>"},{"location":"fundamentals/variables-and-data-types/#boolean-values","title":"Boolean values","text":"<p>Boolean value is simply either <code>True</code> or <code>False</code>. Boolean values are often used to represent ON/OFF state. For example, if you're developing a program to control the lights remotely, you might need a boolean value to represent the current state of lights.</p> <p>In Python, we have <code>bool</code> type to represent boolean values. There are only two boolean literals, <code>True</code> and <code>False</code>.</p> CodeOutput <pre><code>lights_on = True\nprint(lights_on)\nprint(type(lights_on))\n</code></pre> <pre><code>True\n&lt;class 'bool'&gt;\n</code></pre> <p>Tip</p> <p>Booleans are used in logical expressions and  conditionals. These topics are covered in later sections.</p>"},{"location":"fundamentals/variables-and-data-types/#converting-data-types","title":"Converting data types","text":"<p>In programming, it is important to ensure that each data is in its appropriate data type. This is done to ensure that proper operations can be performed on the data.</p> <p>For example, if you have two numeric strings <code>\"20\"</code> and <code>\"30\"</code>, you cannot add these two until they are converted to integer type.</p> CodeOutput <pre><code>n1 = \"20\"\nn2 = \"30\"\nprint(n1 + n2)\n</code></pre> <pre><code>2030 # (1)!\n</code></pre> <ol> <li>The two strings are joined together instead of expected mathematical addition    operation.</li> </ol> <p>In order to convert a data into a different type, we can call that data type with the value that needs to be converted.</p> <p>For example, we can convert a numeric string to integer:</p> CodeOutput <pre><code>n1 = '20'\nn2 = '30'\n\nn1 = int(n1)\nn2 = int(n2)\n\nprint(n1 + n2)\n</code></pre> <pre><code>50\n</code></pre> <p>Similar to this, a string can also be converted to <code>float</code> and <code>bool</code>. Note that conversion can only occur successfully if the string is convertable to the given type. That is, in case of integers, all characters in a string are numbers.</p> <pre><code>x = 'hello'\ny = int(x)  # (1)!\n</code></pre> <ol> <li>Raises an error as <code>x</code> cannot be converted to integer.</li> </ol> <p>Exercise</p> ProblemSolution <p>For each scenario, think of an appropriate Python data type that can be used.</p> <ol> <li>To store the address of a user.</li> <li>To store the phone number of a user.</li> <li>To store the height of user.</li> <li>To store whether the user is over 18 or not.</li> </ol> <ol> <li>To store the address of a user: <code>str</code></li> </ol> <p>Because address is a text, we must use a string to store it.</p> <ol> <li>To store the phone number of a user: <code>str</code></li> </ol> <p>Phone numbers are a set of digits and could also include dashes or plus symbols, so a string.</p> <ol> <li>To store the height of user: <code>float</code></li> </ol> <p>Heights can vary in decimals so floating point number is appropriate to use here.</p> <ol> <li>To store whether the user is over 18 or not: <code>bool</code></li> </ol> <p>Since there are only two possible cases here: over 18 or not over 18, we can use simply use a boolean value which if True, represents that user is over 18 and vice versa.</p>"},{"location":"fundamentals/variables-and-data-types/#variable-types","title":"Variable Types","text":"<p>If you've used another statically typed programming language, you may be aware that variables can have fixed types and once declared, they cannot change type. This isn't the case in Python. Python is a dynamically typed language which means type can change at runtime.</p> <p>For example, in this case, we first assign age an <code>int</code> but we can update it afterwards to hold a <code>str</code> type value. This code would execute without any errors.</p> <pre><code>age = 20\nage = '20'\n</code></pre> <p>In short, the type of variable isn't fixed and can change during the execution of program.</p>"},{"location":"getting-started/installing-python/","title":"1.1. Installing Python","text":"<p>This page goes over the process of installing Python in your machine.</p> <p>Info</p> <p>It is recommended that you install the latest marked version. This guide is for Python 3. Python 2 is not supported by this guide. Python 3.8 or any higher version is recommended.</p>"},{"location":"getting-started/installing-python/#on-windows","title":"On Windows","text":"<p>To install Python, first download its setup from python.org/downloads.</p> <p></p> <p>This will download the setup for Python. After downloading, open the setup. Make sure you tick both of shown checkboxes before clicking \"Install Now\":</p> <p></p> <ul> <li> <p>Use admin privileges when installing py.exe ensures installation is done as   administrator to prevent any potential permission issues while installation.</p> </li> <li> <p>Add python.exe to PATH allows you to use the <code>python</code> in command line to run   your programs or use interpreter on command line. This would be useful throughout   this guide.</p> </li> </ul> <p>After clicking Install Now, Python installation would start. Click \"Yes\" when prompted with administrator popup.</p>"},{"location":"getting-started/installing-python/#on-macos","title":"On MacOS","text":"<p>Setup for MacOS can be downloaded from the same page and follows a similar straight forward installation procedure.</p>"},{"location":"getting-started/installing-python/#on-linux","title":"On Linux","text":"<p>On linux based operating systems, Python may already be installed.</p> <p>To see the version of Python 3 installed, run the following command: <pre><code>$ python3 --version\n</code></pre></p> <p>In case Python is not installed, you can install it using: <pre><code>$ sudo apt-get update\n$ sudo apt-get install python3.12\n</code></pre> To install a different version, change the suffix of second command to include that version.</p> <p>After installation, use the <code>python</code> command in terminal (<code>python3</code> for Linux) to ensure that installation was successful. You should get an output something like this: <pre><code>$ python\nPython 3.11.2 (tags/v3.11.2:878ead1, Feb  7 2023, 16:38:35) [MSC v.1934 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; \n</code></pre></p> <p>If you did everything correctly, Python should be installed. Congratulations.</p>"},{"location":"getting-started/python-environments/","title":"1.2. Python Environments","text":"<p>When it comes to writing Python programs, you need a code editor or IDE to do so.</p> <p>Technically, a notepad can be used too but using a code editor is the preferred way as it provides features that are almost essential for a smooth programming experience.</p> <p>If you have experience with programming, you are probably already aware of setting up code editor or IDE. In case not, this page is for you.</p> <p>There are many choices of editors that you can use. We recommend using PyCharm or Visual Studio Code.</p>"},{"location":"getting-started/python-environments/#pycharm","title":"PyCharm","text":"<p>PyCharm is an IDE specifically for Python. It comes packed with all the features you need for a smooth programming experience.</p> <p>The installation for this editor is rather straight forward. Check out PyCharm website for more information.</p>"},{"location":"getting-started/python-environments/#visual-studio-code","title":"Visual Studio Code","text":"<p>Visual Studio Code (VSCode or VSC for short) is a source code editor. It is an extendible editor powered by official and community extensions that provide support for various programming languages.</p> <p>Follow this official guide to easily setup VSCode for Python programming.</p> <p>Info</p> <p>Make sure you install the editor and follow the relevant guide for setting it up before proceeding to the next page.</p>"},{"location":"getting-started/the-first-program/","title":"1.3. Hello, World!","text":"<p>Now that we have installed Python and setup a Python environment, we can proceed to write our first program. The moment of truth.</p> <p>Create a new file in your code editor or IDE and name it <code>main.py</code>. In this file, include your first line of Python code:</p> CodeOutput <pre><code>print('Hello, World!')\n</code></pre> <pre><code>Hello World\n</code></pre> <p>Tip</p> <p>Throughout this guide, code blocks are used to showcase code snippets like the one above. Click on the <code>Output</code> tab to see the expected output of the code.</p> <p>Yep, that's it. That's the most basic Python program that outputs the given message on screen (<code>Hello, World</code> in this case).</p> <p>Run this program from your code editor or command line. If you're using one of the editors listed in 1.2. Python Environments, it should provide a \"Run Code\" button. If not, you can execute the following command in the terminal:</p> <pre><code>$ python main.py\n</code></pre> <p>You should see the following output:</p> <pre><code>Hello, World!\n</code></pre> <p>Voil\u00e0! Congratulations on successfully running your first program!</p>"},{"location":"getting-started/the-first-program/#the-print-statement","title":"The <code>print</code> statement","text":"<p>Let us understand what is going in this single line of code. We're using the <code>print</code> function here. This function is used to output the given message. Throughout this guide, you'll notice we extensively use this function.</p> <p>We are calling <code>print</code> function with the message to output inside brackets, enclosed in quotes. It is important to enclose the message in quotes. We'll learn more about this in the next section.</p>"},{"location":"string-operations/formatting-strings/","title":"4.3. Formatting Strings","text":"<p>In this section, we'll discuss some ways of formatting strings.</p>"},{"location":"string-operations/formatting-strings/#concatenating-strings","title":"Concatenating strings","text":"<p>Two strings can be added to produce a new joined string.</p> CodeOutput <pre><code>string1 = 'Hello'\nstring2 = 'World'\nprint(string1 + ' ' + string2)\n</code></pre> <pre><code>Hello World\n</code></pre> <p>Note that a string can only be added to a string. If we add another data type to a string, an error is raised:</p> CodeOutput <pre><code>to_add = 1\nprint('Hello' + to_add)\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"G:\\thepyguide\\main.py\", line 2, in &lt;module&gt;\n    print('Hello' + to_add)\n        ~~~~~~~~^~~\nTypeError: can only concatenate str (not \"int\") to str\n</code></pre> <p>The right way of doing this is to convert the value to be added to string before addition:</p> CodeOutput <pre><code>to_add = 1\nprint('Hello' + str(to_add))\n</code></pre> <pre><code>Hello1\n</code></pre>"},{"location":"string-operations/formatting-strings/#the-format-method","title":"The <code>format()</code> method","text":"<p>The <code>format()</code> method is used to format a string and include variable values to it.</p> CodeOutput <pre><code>name = input('Enter your name: ')\nnickname = input('Enter your nickname: ')\n\ngreeting = 'Hello, {}. I will call you {} from now'.format(name, nickname)\nprint(greeting)\n</code></pre> <pre><code>Enter your name: John\nEnter your nickname: Jay\nHello, John. I will call you Jay from now\n</code></pre> <p><code>{}</code> placeholder is replaced with the arguments provided to <code>format()</code> method. Note the order is important. The first argument is substituted with first <code>{}</code> in the string and vice versa.</p>"},{"location":"string-operations/formatting-strings/#changing-placeholders-order","title":"Changing placeholders order","text":"<p>To change the order, the indexes can be used:</p> CodeOutput <pre><code>name = input('Enter your name: ')\nnickname = input('Enter your nickname: ')\n\ngreeting = 'Hello, {1}. I will call you {0} from now'.format(name, nickname)\nprint(greeting)\n</code></pre> <pre><code>Enter your name: John\nEnter your nickname: Jay\nHello, Jay. I will call you John from now\n</code></pre> <p>Here, <code>{1}</code> is replaced with second argument and <code>{0}</code> is replaced with first argument.</p>"},{"location":"string-operations/formatting-strings/#different-data-types","title":"Different data types","text":"<p>Unlike concatenating strings, the arguments in <code>format()</code> are automatically converted to string and don't have to be of <code>str</code> data type.</p> CodeOutput <pre><code>n1 = int(input('Enter first number: '))\nn2 = int(input('Enter second number: '))\nproduct = n1 * n2\n\nprint('The product is: {}'.format(product))\n</code></pre> <pre><code>Enter first number: 20\nEnter second number: 3\nThe product is 60.\n</code></pre>"},{"location":"string-operations/formatting-strings/#named-placeholders","title":"Named placeholders","text":"<p>The curly brackets could include an identifier name which would be used while formatting the string.</p> CodeOutput <pre><code>template = 'Hello, {real_name}. I will call you {nick} from now'\nname = input('Enter your name: ')\nnickname = input('Enter your nickname: ')\nprint(template.format(real_name=name, nick=nickname))\n</code></pre> <pre><code>Hello, John. I will call you Jay from now.\n</code></pre>"},{"location":"string-operations/formatting-strings/#f-string","title":"f-string","text":"<p>f-string is a more convenient method of formatting. It is clearer and more readable than the <code>format()</code> method.</p> <p>To use an f-string, <code>f</code> is placed before the opening quote of a string and variables or values to include in strings are put in curly brackets.</p> CodeOutput <pre><code>name = input('Enter your name: ')\nnickname = input('Enter your nickname: ')\n\ngreeting = f'Hello, {name}. I will call you {nickname} from now'\nprint(greeting)\n</code></pre> <pre><code>Enter your name: John\nEnter your nickname: Jay\nHello, John. I will call you Jay from now\n</code></pre> <p>Similar to format, the values inside curly brackets could be of any data type and would automatically be converted to string.</p> <p>Expressions could also be used:</p> CodeOutput <pre><code>n1 = int(input('Enter first number: '))\nn2 = int(input('Enter second number: '))\n\nprint(f'The product is: {n1 * n2}')\n</code></pre> <pre><code>Enter first number: 20\nEnter second number: 3\nThe product is: 60\n</code></pre>"},{"location":"string-operations/indexing-strings/","title":"4.1. Indexing Strings","text":"<p>In this section, we'll learn about various operations that we can perform on the <code>str</code> data type to manipulate it.</p>"},{"location":"string-operations/indexing-strings/#understanding-string-indexes","title":"Understanding string indexes","text":"<p>A string can be seen as a list of many characters. For example, <code>\"Hello\"</code> could be seen as a list of characters <code>H</code>,<code>e</code>, <code>l</code>, <code>l</code>, and <code>o</code>.</p> <p>Each character in a string has a specific index. Starting from 0, an index is used to point to a specific character of a string.</p> <p>Example:</p> CodeOutput <pre><code>string = 'Hello World'\nprint(string[0])\nprint(string[1])\nprint(string[2])\n</code></pre> <pre><code>H\ne\nl\n</code></pre> <p></p> <p><code>string[index]</code> returns a separate string that has only one character that was located at the <code>index</code> position in original <code>string</code>.</p> <p>Note</p> <p>Note that a space <code>\" \"</code> is also considered a character. e.g. <code>\"A B C\"</code> has five characters including two spaces and accessing second character, <code>\"A B C\"[1]</code> returns <code>\" \"</code>.</p>"},{"location":"string-operations/indexing-strings/#negative-indexes","title":"Negative indexes","text":"<p>When we have a string with arbitrary number of characters and we want to get a character from the end of string, we can use negative indexes.</p> <p>Negative indexes always start from <code>-1</code> with <code>-1</code> representing the last character of string, <code>-2</code> for second last and so on.</p> CodeOutput <pre><code>string = 'Hello World'\nprint(string[-1])\nprint(string[-2])\nprint(string[-3])\n</code></pre> <pre><code>d\nl\nr\n</code></pre> <p></p>"},{"location":"string-operations/indexing-strings/#the-indexerror-error","title":"The <code>IndexError</code> error","text":"<p><code>IndexError</code> is an error raised when we try to access an index that doesn't exist or exceeds the maximum index.</p> CodeOutput <pre><code>string = 'Hello World'\nprint(string[10])  # last index\nprint(string[11])  # IndexError occurs!\n</code></pre> <pre><code>d\nTraceback (most recent call last):\n  File \"G:\\thepyguide\\main.py\", line 3, in &lt;module&gt;\n    print(string[11])  # IndexError occurs!\n        ~~~~~~^^^^\nIndexError: string index out of range\n</code></pre> <p>The same goes for negative indexes too:</p> CodeOutput <pre><code>string = 'Hello World'\nprint(string[-11])  # last negative index (i.e first character)\nprint(string[-12])\n</code></pre> <pre><code>H\nTraceback (most recent call last):\n  File \"G:\\thepyguide\\main.py\", line 3, in &lt;module&gt;\n    print(string[-12])  # IndexError occurs!\n        ~~~~~~^^^^\nIndexError: string index out of range\n</code></pre> <p>Tip</p> <p>We'll learn later in this guide on how to handle errors using the <code>try</code> and <code>except</code> statements.</p> <p>See Chapter 7. Exception Handling for more information.</p>"},{"location":"string-operations/other-operations/","title":"4.5 Other String Operations","text":"<p>In the previous sections, we saw some basic and common operations that were used to deal with strings. This included:</p> <ul> <li>Indexing Strings</li> <li>Slicing Strings</li> <li>Formatting Strings</li> </ul> <p>In this section, we'll see some other operations that can be performed on a  string.</p>"},{"location":"string-operations/other-operations/#multiplication-the-operator","title":"Multiplication (the <code>*</code> operator)","text":"<p>Characters of a string can be multiplied using the <code>*</code> operator. As such, the characters of string are repeated the number of times it was multiplied with.</p> CodeOutput <pre><code>string = 'abc'\n\nprint(string * 3)\n</code></pre> <pre><code>abcabcabc\n</code></pre> <p>It is worth noting that a new string is created on multiplication and old string remains as is.</p> CodeOutput <pre><code>string = 'abc'\nnew_string = string * 3\n\nprint(string)\nprint(new_string)\n</code></pre> <pre><code>abc\nabcabcabc\n</code></pre>"},{"location":"string-operations/other-operations/#len-function","title":"<code>len()</code> function","text":"<p>The built-in <code>len()</code> function is used to return the length of any sequence.  Since string is a sequence of characters too, it can return the number of characters in the string.</p> CodeOutput <pre><code>string = 'Hello Python'\nlength = len(string)\nprint(f'This string has {length} characters.')\n</code></pre> <pre><code>This string has 11 characters.\n</code></pre> <p>Note</p> <p>Keep in mind that \"space\" is also considered a character.</p>"},{"location":"string-operations/slicing-strings/","title":"4.2. Slicing Strings","text":"<p>In this section, we'll discuss how strings can be sliced to produce substrings.</p>"},{"location":"string-operations/slicing-strings/#understanding-syntax","title":"Understanding syntax","text":"<p>String slicing is used to select some characters from a string to form a new smaller string  (substring).</p> <p>The syntax for string slicing is: <pre><code>string[start:end:step]\n</code></pre></p> <ul> <li><code>start</code> is the index of character to start slicing from</li> <li><code>end</code> is the index of character to slice until (exclusive)</li> <li><code>step</code> is the increment in <code>start</code> for each subsequent character</li> </ul> <p>Note that each of three arguments may be omitted and would be given a default value automatically.</p> <p>Zero based index</p> <p>Keep in mind, as mentioned in previous section, indexes always start from 0.</p>"},{"location":"string-operations/slicing-strings/#basic-usage","title":"Basic Usage","text":"<p><code>string[start:end]</code> returns a substring of <code>string</code> starting from character at <code>start</code> index until character at <code>end - 1</code> index.</p> CodeOutput <pre><code>string = 'Hello World'\nprint(string[6:11])\n</code></pre> <pre><code>World\n</code></pre> <p>Note that in <code>string[start:end]</code>, <code>step</code> defaults to 1.</p> <p>Exclusive upper index</p> <p>The upper index, <code>end</code>, in <code>string[start:end]</code> is exclusive. This means <code>string[6:11]</code> starts from 6th index up until 10th index and doesn't include 11th index.</p>"},{"location":"string-operations/slicing-strings/#substring-from-first-character","title":"Substring from first character","text":"<p>When index before first colon is omitted, it defaults to 0.</p> <p><code>string[:end]</code> returns a substring of <code>string</code> starting from first character until character on the <code>end - 1</code> index.</p> <p>This is equivalent to <code>string[0:end]</code> (<code>start</code> given the default value)</p> CodeOutput <pre><code>string = 'Hello World'\nprint(string[:6])\n</code></pre> <pre><code>Hello\n</code></pre>"},{"location":"string-operations/slicing-strings/#substring-till-last-character","title":"Substring till last character","text":"<p>When index after first colon is omitted, it defaults to 0.</p> <p><code>string[start:]</code> returns a substring of <code>string</code> starting from <code>start</code> index until last character.</p> <p>This is equivalent to <code>string[start:length_of_string]</code> (<code>end</code> given the default value of length of string).</p> CodeOutput <pre><code>string = 'Hello World'\nprint(string[6:])\n</code></pre> <pre><code>World\n</code></pre>"},{"location":"string-operations/slicing-strings/#the-step-parameter","title":"The <code>step</code> parameter","text":"<p><code>step</code> defines the increment in <code>start</code> for each subsequent character in the string.</p> <p><code>string[start:end:step]</code> starts from <code>start</code> index and for each next index, adds <code>step</code> to the <code>start</code> until <code>end</code> is reached.</p> <p>For example, if our <code>string</code> is <code>Hello World</code> and we slice the string using <code>string[0:11:2]</code>,</p> <ul> <li>Start from <code>0</code> (start) index so first character in substring is <code>H</code></li> <li>Add <code>2</code> (step) to <code>0</code> (start) and second character is at index <code>2</code>, <code>l</code></li> <li>Add <code>2</code> (step) to <code>2</code> (previous index) and third character is at index <code>4</code>, <code>o</code></li> <li>Add <code>2</code> (step) to <code>4</code> (previous index) and third character is at index <code>6</code>, <code>W</code></li> <li>Repeat until <code>11</code> (end) is reached so final character would be at index <code>10</code>, <code>d</code></li> </ul> CodeOutput <pre><code>string = 'Hello World'\nprint(string[0:11:2])\n</code></pre> <pre><code>HloWrd\n</code></pre> <p><code>string[0::2]</code> also produces the same result where <code>end</code> is given the default value of <code>11</code> (length of string).</p> <p>Note</p> <p><code>step</code> cannot be zero but could be negative (to move in reverse order).</p>"},{"location":"string-operations/slicing-strings/#negative-indexes","title":"Negative indexes","text":"<p>Negative indexes can be used while slicing to extract characters from end of string.</p> CodeOutput <pre><code>string = 'Hello World'\nprint(string[-10:-6])\n</code></pre> <pre><code>ello\n</code></pre>"},{"location":"string-operations/string-methods/","title":"4.4. String Methods","text":"<p>The <code>str</code> data type provides many useful methods that can be used to manipulate a string.</p> <p>Note</p> <p>A method is a function that can be called on a specific data type. This concept is covered in detail later in the guide.</p> <p>This section lists some of the commonly used and useful ones available on a string.</p> Case Methods <p>These methods are used to change the case of a string:</p> Method Description <code>str.upper()</code> Converts the string to all upper case. <code>str.lower()</code> Converts the string to all lower case. <code>str.capitalize()</code> Changes first character of string to upper case. <code>str.swapcase()</code> Changes lowercase characters to uppercase and vice versa. <code>str.title()</code> Changes first character of each word in string to upper case. CodeOutput <pre><code>string = input('Enter some text: ')\n\nprint('upper:', string.upper())\nprint('lower:', string.lower())\nprint('capitalize:', string.capitalize())\nprint('swapcase:', string.swapcase())\nprint('title:', string.title())\n</code></pre> <pre><code>Enter some text: welcome to Python\nupper: WELCOME TO PYTHON\nlower: welcome to python\ncapitalize: Welcome to Python\nswapcase: WELCOME TO pYTHON\ntitle: Welcome To Python\n</code></pre> <code>str.endswith()</code> &amp; <code>str.startswith()</code> <p><code>endswith()</code> and <code>startswith()</code> is used to check whether a string begins with a specific string.</p> CodeOutput (input: <code>Hello</code>)Output (input: <code>Hello?</code>) <pre><code>text = input('Enter a text: ')\nprint('Question?', text.endswith('?'))\n\nif text.endswith('?'):\n    print('You entered a question.')\n</code></pre> <pre><code>Enter a text: Hello\nQuestion? False\n</code></pre> <pre><code>Enter a text: Hello?\nQuestion? True\nYou entered a question.\n</code></pre> <p>They take two optional arguments:</p> <ul> <li><code>start</code> defines the starting index. By default, this is 0 (start of string)</li> <li><code>end</code> defines the ending index. By default, this is length of string (end of string)</li> </ul> CodeOutput <pre><code>text = 'fruits: apple, strawberry, peach'\n\n# searches from 8th index until end of string\nprint(text.startswith('apple', 8))\n\n# searches from 8th index to 25th index (exclusive)\nprint(text.endswith('strawberry', 8, 25))\n</code></pre> <pre><code>True\nTrue\n</code></pre> <code>str.replace()</code> <p><code>str.replace()</code> is used to replace a certain substring in a string with another string. <code>str.replace(old, new)</code> replaces <code>old</code> with <code>new</code>.</p> <p><code>replace()</code> returns a new string with old substring replaced.</p> CodeOutput <pre><code>text = 'Hello, World!'\nnew = text.replace('Hello', 'Bye')\nprint(new)\n</code></pre> <pre><code>Bye, World!\n</code></pre> <p>This method replaces all occurences of given string with new one but could take a <code>count</code> argument to indicate the number of occurences to replace.</p> CodeOutput <pre><code>text = 'apple, peach, strawberry, apple, banana, apple'\nall_replaced = text.replace('apple', '[apple]')\none_replaced = text.replace('apple', '[apple]', 1)\nprint(all_replaced)\nprint(one_replaced)\n</code></pre> <pre><code>[apple], peach, strawberry, [apple], banana, [apple]\n[apple], peach, strawberry, apple, banana, apple\n</code></pre> <code>str.count()</code> <p><code>str.counts()</code> counts the number of times a substring has occured in a string.</p> CodeOutput <pre><code>text = 'apple, peach, strawberry, apple, banana, apple'\nprint(f'apple occured {text.count(\"apple\")} times')\n</code></pre> <pre><code>apple occured 3 times\n</code></pre> <p>This method takes optional <code>start</code> and <code>end</code> parameters indicating the starting position to search from and ending position to end search at.</p> <p><code>text.count('apple', 7)</code> starts searching from 7th index, <code>text.count('apple', 7, 14)</code> searches between 7th and 14th (exclusive) position.</p> CodeOutput <pre><code>text = 'apple, peach, strawberry, apple, banana, apple'\nprint(f'apple occured {text.count(\"apple\", 7)} times after 7th index')\nprint(f'apple occured {text.count(\"apple\", 0, 32)} times between first and 32nd index')\n</code></pre> <pre><code>apple occured 2 times after 7th index\napple occured 2 times between first and 32nd index\n</code></pre> <p>In above code, the first output shows the number of occurences after first occurence and second output shows number of occurences except the last one. </p> Validation Methods <p>Some methods provided by strings are used for validation of the string. These are listed below:</p> Method Description <code>str.isalpha()</code> Checks if all characters in the string are alphabet letters. <code>str.isalnum()</code> Checks if all characters in string are alphanumeric. <code>str.isdigit()</code> Checks if all characters in string are digits or integers. <code>str.isidentifier()</code> Checks if the string is a valid variable name. <code>str.isnumeric()</code> Checks if all characters in string are numeric. <code>str.isspace()</code> Checks if all characters in string are blank spaces. <code>str.istitle()</code> Checks if all words in the string start with a capital letter. <code>str.isupper()</code> Checks if all characters in the string are uppercase. <code>str.isupper()</code> Checks if all characters in the string are lowercase. <p>Methods listed above don't take any additional parameters.</p> <p>Example:</p> CodeOutput <pre><code>text1 = 'HELLO'\ntext2 = 'Hello'\nprint(text1.isupper())\nprint(text2.isupper())\n</code></pre> <pre><code>True\nFalse\n</code></pre> <p>There are many other methods provided by the <code>str</code> data type and all of them cannot be listed here. For a list of all methods, check the official Python documentation on this topic.</p>"}]}